GIT:
Настройка Git
Перед началом работы с Git рекомендуется настроить ваше имя пользователя и адрес электронной почты. Эти данные будут использоваться для подписи ваших коммитов. Выполните следующие команды:

git config --global user.name "Ваше имя"
git config --global user.email "ваша_почта@example.com"

Иногда может потребоваться переименовать ветку. Для этого используется команда:

git branch -m <имя_ветки> <новое_имя_ветки>


Если переименовывается текущая ветка, то её имя можно не указывать:

git branch -m <новое_имя_ветки>

После того, как ветка слита в основную, её можно удалить. Для этого используется команда:

git branch -d <имя_ветки>


Если ветка не слита, для удаления нужно использовать команду:

git branch -D <имя_ветки>


Используйте -D с осторожностью, так как это удаляет ветку без предупреждений.


Просмотр удаленных репозиториев:

Команда: git remote -v
Описание: Эта команда выводит список всех удаленных репозиториев, связанных с вашим локальным репозиторием, включая их URL-адреса и типы (fetch и push).

Команда: git remote remove <имя>
Описание: Удаляет указанный удаленный репозиторий из вашего локального репозитория.
Пример:
git remote remove origin

Конфликты: Если у вас и других разработчиков есть изменения в одних и тех же файлах, при выполнении git pull могут возникнуть конфликты слияния. Git отметит эти конфликты в файлах, и вам нужно будет вручную их разрешить, отредактировав файлы и добавив их в индекс (git add) перед коммитом.
Ветки: Убедитесь, что вы работаете на правильной ветке (git checkout <ветка>). Обычно изменения отправляются в ту же ветку на удаленном репозитории.
Права доступа: Вам должны быть предоставлены права доступа к записи в удаленный репозиторий, чтобы отправлять изменения (git push).

2й Модуль
Добавил PostgreSQL в переменные среды:
    Откройте Параметры Windows (Win + I)
    Перейдите в: Система → О системе → Дополнительные параметры системы (внизу)
    Во вкладке Дополнительно нажмите Переменные среды
    В разделе Системные переменные найдите переменную Path и выберите Изменить
    Нажмите Создать и добавьте путь (например: C:\Program Files\PostgreSQL\17\bin)
    Нажмите OK во всех окнах
    Перезапустил PyCharm - т.к. не обновлялся терминал

psql -h localhost -p 5432 -U django_orm -d django_orm_db -подключение к серверу бд, предварительно создал пользователя и бд, хост указан в свойствах сервера - connections - host name
CREATE USER hr WITH PASSWORD '251125';
pip install "psycopg[binary]"

Чтобы в дальнейшем, для взаимодействия с таблицей hr_employee можно было запустить команду shell_plus, которая идет в пакете django-extensions, установим этот пакет:
pip install django-extensions


Если нам нужно вернуться к миграции 0005 из миграции 0006, мы выполним следующую команду:
python manage.py migrate hr 0005 или: python manage.py migrate hr 0005_second_last_migration

Если нам нужно отменить все миграции приложения hr, мы воспользуемся следующей командой:
python manage.py migrate hr zero



Помните, что иногда миграция может быть необратимой. Как правило, это состояние возникает, когда в модели Django были внесены некоторые существенные изменения. Когда мы попытаемся вернуться к такой миграции, Django выдаст IrreversibleError.


Если нам нужно полностью очистить всю базу данных, мы можем использовать следующую команду:
python manage.py flush


default - значение по умолчанию, записываемое в поле, если в него явно не было занесено никакого значения. Может быть указано двумя способами:
Как обычное значение любого неизменяемого типа:
is_active = models.BooleanField(default=True)
Если в качестве значения по умолчанию должно выступать значение изменяемого типа (список или словарь Python), то для его указания следует использовать второй способ.
Как ссылка на функцию, вызываемую при создании каждой новой записи и возвращающую в качестве результата заносимое в поле значение:
def is_active_default():
    return not is_all_posts_passive
...
...
is_active = models.BooleanField(default=is_active_default)

unique_for_date - если в этом параметре указать представленное в виде строки имя поля даты (DateField) или даты и времени (DateTimeField), то текущее поле может хранить только значения, уникальные в пределах даты, которая хранится в указанном поле. Пример:
title = models.CharField(max_length=50, unique_for_date='published')
published = models.DateTimeField()
В этом случае Django позволит сохранить в поле title только значения, уникальные в пределах даты, хранящейся в поле published;
unique_for_month - то же самое, что и unique_for_date, но в расчет принимается не всё значение даты, а лишь месяц;
unique_for_year - то же самое, что и unique_for_date, но в расчет принимается не всё значение даты, а лишь год;

editаblе - если True, то поле будет выводиться на экран в составе формы, если False - не будет (даже если явно создать его в форме) . По умолчанию - True;
db_column - имя поля таблицы в виде строки. Если не указано, то поле таблицы получит такое же имя, что и поле модели.


class Employee(models.Model):
    class Workplace(models.IntegerChoices):
        JOB_1 = 1, 'Junior'
        JOB_2 = 2, 'Middle'
        JOB_3 = 3, 'Senior'
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    workspace = models.PositiveSmallIntegerField(choices=Workplace.choices, default=Workplace.JOB_1,
    help_text="Position in the company?")
Мы создали класс Choice (перечисление) Workplace, который имеет 3 "уровня работников". Первая часть (например, JOB_1) — это имя  перечисления. Вторая часть (например, 1) является фактическим значением. Третья часть (например. 'Junior') представляет собой удобочитаемое имя, метку. Это то, что вы увидите в админке.
Класс Choices имеет два подкласса — IntegerChoicesи TextChoices. Поскольку нас интересуют только номера "уровней работников", мы использовали IntegerChoices(неважно, что имена констант и метки строковые, вы выбираете тип на основе значений).

python manage.py shell_plus --print-sql

Вторым параметром on_delete указывается поведение фреймворка в случае, если будет выполнена попытка удалить запись первичной модели, на которую ссылаются какие-либо записи вторичной модели. Параметру присваивается значение одной
из переменных, объявленных в модуле django.db.models:
CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление);
PROTECT - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели;
SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null конструктора поля имеет значение True);
SET_DEFAULT - заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том случае, если у поля внешнего ключа было указано значение по умолчанию (оно задается параметром default конструктора поля);
SET(<значение>) - заносит в поле внешнего ключа указанное значение:
department = models.ForeignKey(Department, on_delete=models.SET(1))
Также можно указать ссылку на функцию, не принимающую параметров и возвращающую значение, которое будет записано в поле:
def get_first_department():
    return Department.objects.first()
department = models.ForeignKey(Department, on_delete=models.SET(get_first_department))
DO_NOTHING - ничего не делает.

Из-за асимметричности отношений нам необходимо использовать Django метод <object>_set(). Он возвращает QuerySet, например employee_set вернет всех сотрудников отдела:
d = Department.objects.get(id=1)
d.employee_set.all()
Обратите внимание, что мы не определяли employee_set свойство в Department модели. Внутри Django автоматически добавил employee_set свойство в Departmentмодель, когда мы определили отношение «один-ко-многим» с помощью ForeignKey.
Метод employee_set.all() возвращает QuerySet, который содержит всех сотрудников, принадлежащих к отделу.


С помощью следующего кода, мы можем получить первого сотрудника:
e = Employee.objects.first()
Для доступа к отделу первого сотрудника вы используете атрибут department:
e.department
В этом случае Django все также выполняет два запроса. Первый запрос выбирает первого сотрудника, а второй запрос выбирает отдел выбранного сотрудника. Эти запросы можно оптизимизировать используя метод select_related().


Класс ForeignKey поддерживает следующие дополнительные необязательные параметры:
limit_choices_to - позволяет вывести в раскрывающемся списке записей первичной модели, отображаемом в веб-форме, только записи, удовлетворяющие заданным критериям фильтрации. Критерии фильтрации записываются в виде словаря Python, имена элементов которого совпадают с именами полей первичной модели, по которым должна выполняться фильтрация, а значения элементов укажут значения для этих полей. Выведены будут записи, удовлетворяющие всем критериям, заданным в таком словаре (т.е. критерии объединяются по правилу логического И). Мы можем добавить в модель Department новое поле actions. И после укажем Django выводить только рубрики, поле actions которых содержит значение True:
department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, limit_choices_to={'actions': True})

related_name - имя атрибута записи первичной модели, предназначенного для доступа к связанным записям вторичной модели, в виде строки. По умолчанию обратное отношение будет называться ****_set.
Однако вы можете изменить имя обратного отношения с помощью атрибута related_name.
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, related_name='test')
Если доступ из записи первичной модели к связанным записям вторичной модели не требуется, можно указать Django не создавать такой атрибут. Для этого достаточно присвоить параметру related_name = "+". Если параметр не указан, то атрибут такого рода получит стандартное имя вида <имя связанной вторичной модели>_sеt

related_query_name - имя фильтра, которое будет применяться во вторичной модели для фильтрации по значениям из записи первичной модели:
department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, related_query_name='entry')

to_field - имя поля первичной модели, по которому будет выполнена связь, в виде строки . Такое поле должно быть помечено как уникальное (параметр unique конструктора должен иметь значение True). Если параметр не указан, связывание выполняется по ключевому полю первичной модели - неважно, созданному явно или не явно;

db_constraint - если True, то в таблице базы данных будет создана связь, позволяющая сохранять ссылочную целостность, если False, ссылочная целостность будет поддерживаться только на уровне Django. Значение по умолчанию - True. Менять его на False имеет смысл, только если модель создается на основе уже существующей базы с некорректными данными.



Внешний ключ employee_id ссылается на id таблицы hr_employee, а compensation_id соответственно на id таблицы hr_compensations.
Как правило, вам не нужен столбец id в таблице hr_employee_compensations в качестве первичного ключа , и вы можете использовать оба employee_id и compensation_id в качестве составного первичного ключа. Однако Django всегда создает столбец id в качестве первичного ключа для таблицы соединения.
Кроме того, Django создает уникальное ограничение , включающее столбцы employee_id и compensation_id. Другими словами, в таблице не будет повторяющихся пар employee_id и compensation_id значений hr_employee_compensations.


Добавление оплаты сотрудникам
Сначала зарегистрируйте сотрудника John Doe в компенсационных программах stock (c1) и bonuses (c2), используя метод add() атрибута compensations:
e.compensations.add(c1)
e.compensations.add(c2)
Во-вторых, необходимо получить доступ ко всей compensations программе с John Doe использованием метода all() атрибута compensations:
e.compensations.all()

Django позволяет вам запрашивать отношения. Например, вы можете найти всех сотрудников, у которых есть компенсация с идентификатором 1:
Employee.objects.filter(compensations__id=1)
Или с именем "Profit Sharing":
Employee.objects.filter(compensations__name="Profit Sharing")

Снятие связи зарплат с сотрудников
Для снятия зарплатной программы с работника используется метод remove() атрибута compensations объекта Employee. Например:
Сначала найдите сотрудника, имя которого Jane Doe:
e = Employee.objects.filter(first_name='Jane', last_name='Doe').first()
e.compensations.remove(c3)



Конструктор класса ManyToManyField поддерживает дополнительные необязательные параметры limit_choices_to, related_name, related_query_name и db_constraint, описанные в предыдущем разделе , а также следующие:
symmetrical - используется только в тех случаях, когда модель связывается сама с собой. Если True, Django создаст симметричную связь, действующую в обоих направлениях. Если False, то связь будет асимметричной. Значение по умолчанию - True. Для асимметричной связи Django создаст в классе модели атрибут для доступа к записям связанной модели в обратном направлении.
through - класс модели, которая представляет связующую таблицу (связующая модель) либо в виде ссылки, либо в виде имени, представленном строкой. Если класс не указан, то связующая таблица будет создана самим Django. При использовании связующей модели нужно иметь в виду следующее, что в связующей модели следует явно объявить поля внешних ключей для установления связи с обеими связываемыми моделями: и ведущей, и ведомой;
Например если мы используем модель:
from django.db import models
class Student(models.Model):
    name = models.CharField(max_length=200)
class Course(models.Model):
    name = models.CharField(max_length=200)
    students = models.ManyToManyField(Student, through='Register')
class Register(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    date = models.DateField()

through_fields - используется, если связь устанавливается через связующую модель, записанную в параметре through конструктора. Указывает поля внешних ключей, по которым будет создаваться связь. Значение параметра должно представлять собой кортеж из двух элементов: имени поля ведущей модели и имени поля ведомой модели, записанных в виде строк. Если параметр не указан, то поля будут созданы самим фреймворком. Например если мы используем модель:
from django.db import models
class Student(models.Model):
    name = models.CharField(max_length=200)
class Course(models.Model):
    name = models.CharField(max_length=200)
    students = models.ManyToManyField(Student, through='Register', through_fields=('course', 'student'))
class Register(models.Model):
    student = models.ForeignKey(Student, related_name='student', on_delete=models.CASCADE)
    intern = models.ForeignKey(Student, related_name='intern', on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    date = models.DateField()
В приведенном выше примере модель Register имеет два внешних ключа Student у полей student и intern, теперь Django не знает, какой из них использовать, и в результате не сможет создать таблицы. В этом случае вы должны явно указать, какие внешние ключи Django должен использовать с помощью through_fields.

db_table - имя связующей таблицы. Обычно применяется, если связующая модель не используется. Если оно не указано, то связующая таблица получит имя по умолчанию.

Ключевые характеристики QuerySets:
Ленивая оценка (Lazy evaluation): QuerySet не выполняет запрос к базе данных до тех пор, пока вы не попытаетесь получить доступ к его данным (например, с помощью цикла for, индексации или вызова метода, возвращающего данные). Это позволяет оптимизировать работу с данными, особенно когда вам нужен только небольшой поднабор данных.
Итерируемость: QuerySet можно использовать в циклах for для итерации по полученным объектам.
Цепочки методов: QuerySets поддерживают цепочки методов (методы, которые возвращают новый QuerySet). Это позволяет создавать сложные запросы к базе данных в читаемом и понятном виде. Например: Post.objects.filter(published=True).order_by('-published_date')
Кэширование: QuerySets кэшируют результаты, чтобы избежать повторных обращений к базе данных, если вы несколько раз запрашиваете одни и те же данные.
Представление данных: QuerySets возвращают объекты Python, соответствующие вашей модели. Это позволяет легко работать с данными, используя атрибуты модели.


етоды возвращающие QuerySet
filter(): Фильтр по заданным параметрам поиска. Несколько  параметров объединяются операторами SQL AND.
exclude(): Фильтр по объектам, которые не соответствуют заданным параметрам поиска.
annotate(): Аннотирует каждый объект в QuerySet. Аннотации могут быть простыми значениями, ссылкой на поле или агрегированным выражением.
alias(): То же, что annotate(), но вместо аннотирования объектов в QuerySet, сохраняет выражение для последующего повторного использования с другими QuerySet методами.
order_by(): Изменение сортировки QuerySet по умолчанию.
reverse(): Сортирует QuerySet по умолчанию в обратном порядке.
distinct(): Выполнение SQL запроса SELECT DISTINCT для устранения дублирующихся строк.
values(): Возвращает словари вместо экземпляров моделей.
values_list(): Возвращает кортежи вместо экземпляров модели.
dates(): Возвращает QuerySet, содержащий все доступные даты в указанном диапазоне дат.
datetimes(): Возвращает QuerySet, содержащий все доступные даты в указанном диапазоне дат и времени.
none(): Создает пустой QuerySet.
all(): Возвращает копию текущего QuerySet-а.
union(): Использует SQL оператор UNION для объединения двух или более QuerySet.
intersection(): Использует SQL оператор INTERSECT для возврата общих элементов двух или более QuerySet.
difference(): Использует SQL оператор EXCEPT для возврата элементов первичного QuerySet которых нет в других.
select_related(): Выборка всех связанных данных при выполнении запроса (за исключением отношений многие-ко-многим).
prefetch_related(): Выборка всех связанных данных при выполнении запроса related()(включая отношения многие-ко-многим).
extra(): Метод используется для переименования столбцов в ORM.
defer(): Не извлекает указанные поля из БД. Используется для улучшения производительности запросов со сложными наборами данных.
only(): Противоположность метода defer() - возвращает только указанные поля.
using(): Выбирает, в какой базе данных будет оцениваться QuerySet(при использовании нескольких баз данных).
select_for_update(): Возвращает QuerySet и блокирует строки таблицы до завершения транзакции.
raw(): Выполняет исходный SQL оператор.
&: Комбинирует два QuerySet с помощью SQL оператора AND.
|: Комбинирует два QuerySet с помощью SQL оператора OR.
^: Комбинирует два QuerySet с помощью SQL оператора XOR.


annotate()
Метод annotate() позволяет добавлять вычисляемые атрибуты к объектам в QuerySet. Эти атрибуты не хранятся в базе данных, а вычисляются "на лету". Аннотации могут быть простыми значениями, ссылкой на поле или агрегированным выражением.
Имена вычисляемых атрибутов задаются через именованные аргументы, передаваемые в данный метод, например при такой аннотации:
Model.objects.annotate(my_attr_name=expr)
К каждому объекту в QuerySet будет добавлен атрибут my_attr_name со значением, полученным в результате вычисления выражения expr.
Метод annotate() часто используется с агрегационными функциями (такими как Sum, Avg, Count) для вычисления значений на основе связанных объектов. При этом можно не задавать имя для вычисляемого атрибута, оно будет сгенерировано на основе имени поля или поискового выражения по полю (переданного в данную функцию) и имени функции, например при такой аннотации:
Model.objects.annotate(Count('field'))
К каждому объекту в QuerySet будет добавлен атрибут field__count со значением, полученным в результате вычисления выражения Count('field').
Если в метод annotate() передаются выражения с заданием имени вычисляемого атрибута и без, то сначала необходимо указывать выражения без задания имени (позиционные аргументы), а только затем с заданием (именованные аргументы).
Model.objects.annotate(Count('field'), my_attr_name=expr)
Вычисляемые атрибуты можно использовать с другими QuerySet методами, например фильтровать по ним или сортировать.
Давайте воспользуемся агрегационной функцией Django Count() для аннотирования нашей модели Employee для вычисления количества зарплатных программ у каждого работника:
e = Employee.objects.annotate(compensations_count=Count('compensations'))
for i in e:
    print(i.first_name, i.last_name, i.compensations_count)

exclude()
Можно исключить некоторые результаты из запроса с помощью метода exclude().
Employee.objects.exclude(first_name='John')


alias()
То же, что и метод annotate(), но вместо аннотирования объектов в QuerySet, сохраняет выражение для последующего повторного использования с другими QuerySet методами. Это полезно, когда результат самого выражения не нужен, но он используется для фильтрации, упорядочивания или как часть сложного выражения.
Например, если вы хотите найти работников с 2 и более чем зарплатными программами, вы можете сделать это:
Employee.objects.alias(compensations_count=Count('compensations')).filter(compensations_count__gte=2)
Метод alias() можно использовать вместе с методами annotate(), exclude(), filter(), order_by()и update().


Чтобы отсортировать случайным образом, вы можете использовать вопросительный знак ?:
Employee.objects.order_by('?')
Сортировка случайным образом с помощью метода order_by('?') может быть медленной и ресурсозатратной, в зависимости от используемой базы данных.


Также метод order_by() может упорядочивать по полю в связанной модели. Синтаксис поля — связанная модель, за которой следуют двойные символы подчеркивания и имя поля:
model.objects.order_by(related_model__field_name)

reverse()
Делает упорядочивание по умолчанию QuerySet в обратном порядке. Чтобы функция reverse() была использована, модель должна иметь упорядочивание по умолчанию (путем установки ordering в Meta-классе модели). Если модель не упорядочена, то сортировка возвращаемого QuerySet будет бессмысленной.

distinct()
Устраняет дубликаты данных из QuerySet. Создадим еще одного работника, который будет дублировать уже существующего сотрудника.
С помощью данного запроса мы можем не выводить сотрудников, у которых повторяются имена.
Employee.objects.all().distinct('first_name')


values()
Метод values() возвращает QuerySet словарей, в которых ключами будут имена полей, а значениями - их значения. Данный метод позволяет указать какие значения полей необходимо вернуть в результирующих словарях, для этого надо передать имена полей, в виде строк, в данный метод. Если в метод не было передано ни одного имени поля, то в результирующем словаре будут все поля, например:
Employee.objects.filter(id=1).values()
Кроме имён полей, можно передавать в данный метод и выражения, например:
Model.objects.values(my_key1=F('field1')*F('field2'), my_key2=Count('field3'))
При этом произойдёт добавление ключей в результирующие словари QuerySet, которые были переданы в данный метод в виде именованных аргументов. Это более удобный способ, чем использовать предварительное аннотирование, как в этом примере:
Model.objects.annotate(my_key1=F('field1')*F('field2'), my_key2=Count('field3')).values('my_key1', 'my_key2')



Метод values_list() возвращает QuerySet кортежей, в которых элементами будут значения полей. Как и метод values(), данный метод позволяет указать какие значения полей необходимо вернуть в результирующих кортежах, для этого надо передать имена полей, в виде строк, в данный метод. Полученные значения полей будут находиться в той же последовательности, что и имена полей, переданные в данный метод, например:
Employee.objects.filter(last_name='Doe').values_list('first_name', 'last_name')
Если в метод не было передано ни одного имени поля, то в результирующем кортеже будут значения всех полей, в той же последовательности, что и порядок следования полей в модели, например:
Employee.objects.filter(id=1).values_list()
Кроме имён полей, можно передавать в данный метод и выражения, например:
Model.objects.values_list(F('field1')*F('field2'), Count('field3'))
При запросе только одного поля можно передать в метод дополнительный аргумент flat=True, чтобы получить QuerySet, содержащий непосредственно значения этого поля, а не QuerySet с кортежами, которые содержат по одному элементу


dates() и datetimes()
Методы dates() и datetimes() позволяют возвращать, из базы данных, записи привязанные к определённому времени (например, все события, происходящие в конкретном месяце). Для метода dates() это ограничения времени по году, месяцу, неделе и дню. Для метода datetimes() добавляются ещё и ограничения по часам, минутам и секундам. Например:
Employee.objects.dates('created', 'day')


none()
Метод none() возвращает пустой набор данных в виде объекта EmptyQuerySet. Одно из применений метода none() - это когда вы не знаете, будут ли объекты, но не хотите при этом вызвать ошибку.


union()
Данный метод используется для объединения набора результатов двух или более наборов запросов. Наборы запросов могут быть из одной или разных моделей. Когда наборы запросов относятся к разным моделям, поля и их типы данных должны совпадать.



Попробуем на практике, выберем всех сотрудников, возрастом до 30 лет.
e1 = Employee.objects.filter(age__lte=30)
Теперь в другую переменную, выберем всех сотрудников, возрастом старше 30 лет.
e2 = Employee.objects.filter(age__gte=30)
И теперь мы можем объединить их, с помощью метода union.
e1.union(e2)
Но если мы попробуем
d = Department.objects.all()
e1.union(d)
То получим ошибку: django.db.utils.ProgrammingError: все запросы в UNION должны возвращать одинаковое число столбцов.  Операция объединения может быть выполнена только с наборами запросов, имеющими одинаковые поля и типы данных. Следовательно, наша последняя операция объединения столкнулась с ошибкой. Вы можете объединить две модели, если они имеют одинаковые поля или подмножество полей.
Employee.objects.values_list('last_name', 'age').union(Department.objects.values_list('name', 'id'))
Поскольку Employee и Department оба имеют поля одинакового типа, мы можем использовать values_list для ограничения выбранных полей, а затем выполнить объединение.


intersection()
Использует SQL оператор INTERSECT для возврата общих элементов двух или более QuerySet-ов. Действуют те же ограничения, как и на union().
Ниже, в примере, мы выбрали первым запросом всех сотрудников возрастом более 25 лет и вторым запросом всех сотрудников моложе 70 лет. И в дальнейшем объединили данные запросы через intersection().
e1 = Employee.objects.filter(age__gte=25)
e2 = Employee.objects.filter(age__lte=70)
e2.intersection(e1)


difference()
Использует оператор SQL EXCEPT для хранения только элементов, присутствующих в QuerySet. Это метод, который выводит только те данные из первого QuerySet, которых нет во втором QuerySet. Действуют те же ограничения, как и на union().
e1 = Employee.objects.filter(age__gte=25)
e2 = Employee.objects.filter(age__lte=70)
e1.difference(e2)



select_related()
В разделе 2.3 "Связь One-To-Many (Один-ко-многим)" мы уже столкнулись с тем, что при присоединении сотрудника к отделу, Django выполняет два запроса. Первый запрос выбирает первого сотрудника, а второй запрос выбирает отдел выбранного сотрудника. Если вы выберете N сотрудников, чтобы отобразить их на веб-странице, вам нужно выполнить N + 1 запрос, чтобы получить как сотрудников, так и их отделы. Первый запрос (1) выбирает N сотрудников, а N запросов выбирает N отделов для каждого сотрудника. Эта проблема известна как проблема запроса N + 1.
Чтобы решить проблему с запросом N + 1, вы можете использовать select_related() метод выбора как сотрудников, так и отделов с помощью одного запроса. Например:
Employee.objects.select_related('department').all()
В этом примере Django выполняет только один запрос, который объединяет таблицы hr_employee и hr_department.



prefetch_related()
Данный метод работает так же, как и select_related(), за исключением того, что он будет работать с отношениями many-to-many.
Employee.objects.prefetch_related('compensations').all()


extra()
Иногда синтаксис запроса Django сам по себе не может легко выразить сложное  предложение WHERE. Для этого был создан метод extra().
Employee.objects.extra(where=["first_name=%s"], params=["John"])
Employee.objects.extra(where=["last_name='Doe' OR first_name = 'John'"])
Что будет приравниваться к запросу:
SELECT * FROM hr_employee WHERE last_name='Doe' OR first_name = 'John'
Более подробно можно почитать в документации - https://docs.djangoproject.com/en/5.2/ref/models/querysets/#extra


defer()
Если в вашей модели Django есть поля, содержащие много данных, и вам не нужны эти поля для определенного запроса, вы можете указать Django не извлекать их с помощью метода defer(). Попробуем вывести первого работника.
Мы видим что у него есть поле 'created'. Попробуем извлечь первого работника используя метод defer чтобы не выводить их дату создания:
Employee.objects.defer('created')


using()
Если если в вашем проекте задействовано несколько баз данных, то этот метод позволит выбрать, какая база данных будет использоваться для запроса. Уникальный параметр этого метода является псевдонимом базы данных, определенным в базах данных.

# запрашивает базу данных 'default'.
>>> Entry.objects.all()
# запрашивает базу данных 'backup'
>>> Entry.objects.using('backup')
В settings.py проекта мы можем задать несколько баз данных и использовать их в зависимости от потребностей через данный метод.

select_for_update()
Метод select_for_update, предлагаемый Django ORM, решает проблему параллелизма, возвращая набор запросов, который блокирует все строки, принадлежащие этому набору запросов, до тех пор, пока самая внешняя транзакция, в которой он находится, не будет закончена, что предотвращает повреждение данных.
Employee.objects.select_for_update().get(id=1)


raw()
Если ваш API-интерфейс запроса модели не может выполнить определенные запросы или вы хотите повысить производительность, вы можете использовать необработанные SQL-запросы в Django. ORM(Object Relational Mapper) помогает преодолеть разрыв между базой данных и нашим кодом, выполняя необработанные запросы через метод raw().
Employee.objects.raw('select * FROM hr_employee')
Возвращает объект <RawQuerySet: select * FROM hr_employee>



AND (&)
Объединяет два запроса QuerySet с помощью оператора SQL AND аналогично цепочке фильтров.
Employee.objects.filter(id=1) & Employee.objects.filter(age__gt=0)
Employee.objects.filter(id=1).filter(age__gt=0)
Это два запроса, которые будут эквивалентны друг другу.


OR (|)
Объединяет два QuerySet с помощью оператора SQL OR.
Employee.objects.filter(id=1) | Employee.objects.filter(id=2)

XOR (^)
Объединяет два QuerySet с помощью оператора SQL XOR.
Employee.objects.filter(id=1) ^ Employee.objects.filter(age__gt=2)


Методы которые не возвращают QuerySet
get(): Возвращает один объект. Вызывает ошибку, если поиск возвращает несколько объектов.
create(): Быстрый метод создания и сохранения объекта за один шаг. Так же данный метод возвращает созданный объект.
get_or_create(): Возвращает один объект. Если объект не существует, то он его создает.
update_or_create(): Обновляет один объект. Если объект не существует, то он его создает.
bulk_create(): Вставляет список объектов в базу данных.
bulk_update(): Обновляет указанные поля в списке экземпляров модели.
count(): Подсчитывает количество объектов в возвращаемом QuerySet. Возвращает целое число.
in_bulk(): Возвращает словарь, содержащий все объекты с указанными ID.
iterator(): Выполнение QuerySet и возвращение итератора по результатам. Может улучшить производительность и потребление памяти при запросах, возвращающих большое количество объектов.
latest(): Возвращает последний объект в таблице базы данных на основе заданного поля (полей).
earliest(): Возвращает самый ранний объект в таблице базы данных на основе заданного поля (полей).
first(): Возвращает первый объект в соответствующем QuerySet.
last(): Возвращает последний объект в соответствующем QuerySet.
aggregate(): Возвращает словарь агрегированных значений (средние, суммы и т.д.), рассчитанных по QuerySet.
exists(): Возвращает True, если QuerySet содержит какие либо результаты.
contains(): Метод возвращает True, если набор QuerySet содержит определенный объект, и False - если не содержит.
update(): Выполняет SQL оператор UPDATE в указанном поле (полях).
delete(): Выполняет SQL оператор DELETE, удаляющий все строки в QuerySet.
as_manager(): Возвращает экземпляр класса Manager, содержащий копию методов QuerySet.
explain(): Возвращает строку плана выполнения QuerySet. Используется для анализа выполнения запросов.


get()
Метод get() возвращает один единственный объект. Если нет совпадения результатов, это вызовет исключение DoesNotExist. Если запросу get() соответствует более одного элемента, то это вызовет исключение MultipleObjects.
Employee.objects.get(id=1)

create()
Удобный метод создания объекта и его сохранения за один шаг. Асинхронная версия acreate()
Department.objects.create(name='Testing', description='Test Engineer')

get_or_create()
Данный метод будет пытаться извлечь запись, соответствующую полям поиска. Если записи не существует, то она будет создана. Возвращаемое значение будет кортежем, в котором будет содержаться созданный или извлеченный объект, а также булевым значением, которое будет True, если была создана новая запись:
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', description='System Administration Department')
>>> e
<Department: Sys_Admin>
>>> bool
True
Если мы попробуем повторить выполнение данного кода, то получим:
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', description='System Administration Department')
>>> e
<Department: Sys_Admin>
>>> bool
False
Также мы можем передать словарь с именем defaults, он позволяет вам указать значения для других полей модели, которые нужно установить при создании нового объекта, не дублируя код.
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', defaults={'description':'System Administration Department'})
Асинхронная версия - aget_or_create()

update_or_create()
Работает аналогично get_or_create(), вы также передаете поля поиска и словарь с именем defaults, содержащий поля для обновления. Если объект не существует, метод создаст новую запись в базе данных:
e, bool = Department.objects.update_or_create(name='Sys_Admin', description='System Administration Department', defaults={'name':'Sys admin'})
Асинхронная версия - aupdate_or_create()

bulk_create()
Метод bulk_create() экономит время, вставляя в базу данных сразу несколько объектов, чаще всего в одном запросе. Функция имеет один обязательный параметр - список объектов:
e = Department.objects.bulk_create([Department(name='Test_bulk', description='Test bulk_create'), Department(name='Test_bulk_2', description='Test bulk_create 2')])
Асинхронная версия - abulk_create()

bulk_update()
Метод bulk_update(), наоборот, берет список объектов модели и обновляет отдельные поля в выбранных экземплярах модели. Данный метод будет работать только со списком объектов, поэтому сначала нужно создать список объектов, который мы хотим обновить:
>>> e = Department.objects.filter(id__gt = 4)
>>> e
<QuerySet [<Department: Test_bulk>, <Department: Test_bulk_2>]>
Затем мы вносим изменения в объекты из списка:
>>> e_list = [e[0], e[1]]
>>> e_list[0].name = 'Test_bulk_update'
>>> e_list[1].name = 'Test_bulk_update_2'
После этого мы уже можем использовать метод bulk_update для сохранения изменений в базе данных в одном запросе:
>>> Department.objects.bulk_update(e_list, ['name'])
Асинхронная версия abulk_update()

count()
Подсчитывает количество объектов в QuerySet. Может использоваться для подсчета всех объектов в таблице базы данных:
>>> Employee.objects.count()
4
Или используется для подсчета количества объектов, возвращенных запросом:
>>> Employee.objects.filter(last_name='Doe').count()
2
Метод count() функционально эквивалентен использованию функции aggregate(), но count() имеет более чистый синтаксис и вероятно будет быстрее в больших наборах данных. Например:
>>> Employee.objects.all().aggregate(Count('id'))
{'id__count': 4}
Асинхронная версия метода - acount().

in_bulk()
Метод берет список значений id и возвращает словарь, с экземплярами объектов которые соответствуют каждому id. Если в список не передать значение, то будут возвращены все объекты:
Employee.objects.in_bulk()
После извлечения, вы можете получить доступ к каждому объекту по его ключевому значению:
Любой непустой список извлечет все записи с указанными id:
Employee.objects.in_bulk([1])
Список c id не обязательно должен быть последовательным:
Асинхронная версия - ain_bulk()

iterator()
QuerySet обычно кеширует свои результаты, когда происходит оценка, и для любых дальнейших операций с этим QuerySet он сначала проверяет кешированные результаты. Но когда вы используете iterator(), он не проверяет кеш и считывает результаты непосредственно из базы данных. Результаты не сохраняются в QuerySet.
Для QuerySet, возвращающего большое количество объектов, которые требуют много памяти для кеширования и к которому вам нужно получить доступ только один раз, вы можете использовать iterator().
Employee.objects.all().iterator()

first()
Возвращает первый объект, соответствующий набору запросов или None, если нет подходящего объекта. Если в наборе запросов порядок не определен, то набор запросов автоматически упорядочивается по первичному ключу.
Employee.objects.first()

last()
Возвращает последний объект, соответствующий набору запросов или None, если нет подходящего объекта. Если в наборе запросов порядок не определен, то набор запросов автоматически упорядочивается по первичному ключу.
Employee.objects.last()

earliest() и latest()
 Возвращает первый объект или последний объект, в порядке для указанного в методе поля(полей):
Employee.objects.latest('created')
Employee.objects.earliest('created')
Если в данном методе поле(поля) не указаны, то значение их берётся из атрибута get_latest_by класса Meta данной модели.
Данные методы можно рассматривать как эквиваленты методов order_by('поле').first() и order_by('поле').last(), но с отличием в том, что методы earliest() и latest() вызывают исключение DoesNotExist, если нет подходящего объекта.

aggregate()
Возвращает словарь агрегированных значений, вычисленных по QuerySet.
Department.objects.aggregate(Count('name'))

exists()
Возвращает True, если полученный QuerySet содержит один или несколько объектов, False, если QuerySet пустой.
Employee.objects.filter(first_name='Bill').exists()
В случае если ответ не содержит объекты, получим False

contains()
Метод contains() возвращает True, если QuerySet содержит определенный объект, и False - если не содержит:
e = Employee.objects.filter(first_name="John")
Employee.objects.filter(age__gte=35).contains(e)
>>> True
Асинхронная версия acontains()

update()
Еще один способ обновления объектов представляет метод update() в сочетании с методом filter (будет 1 запрос к БД):
Employee.objects.filter(age__lt=30).update(department=2)

В данном примере мы выбрали всех сотрудников моложе 30 лет и присвоили их к отделу с id = 2.
Асинхронная версия aupdate()

delete()
Для удаления мы можем вызвать метод delete() (либо его) у удаляемого объекта:
e = Employee.objects.get(id=1)
e.delete()

Если не требуется получение отдельного объекта из базы данных, тогда можно удалить объект с помощью комбинации методов filter() и delete():
Employee.objects.filter(age__lt=30).delete()
Асинхронная версия adelete()

as_manager()
Метод класса, возвращающий экземпляр Manager с копией QuerySet методов.

explain()
Этот метод возвращает строку анализа выполнения QuerySet. Используется для анализа производительности запросов.
Employee.objects.filter(age__lt=20).explain()

Полный список поисковых полей Django
exact/iexact    Точное совпадение. iexact - версия без учета регистра.
contains/icontains    Поле содержит текст поиска. icontains это версия без учета регистра.
in    В указанной итерации (список, кортеж или QuerySet)
gt/gte    Больше чем / больше чем или равно
lt/lte    Меньше чем/меньше чем или равно
startswith/istartswith    Начинается в строке поиска. istartswith это версия без учета регистра.
endswith/iendswith    Заканчивается в строке поиска. iendswith это версия без учета регистра.
range    Тест диапазона. Диапазон включает в себя начальное и конечное значения
date    Передает значение в виде даты. Используется для поиска полей datetime
year    Поиск точного совпадения года
iso_year    Поиск точного совпадения по году ISO 8601
month    Поиск точного совпадения месяца
day    Поиск точного совпадения дня
week    Поиск точного совпадения недели
week_day    Поиск точного совпадения дня недели
quarter    Поиск точного совпадения квартала года.
time    Использует значение времени. Используется для поиска полей datetime
hour/minute/second    Поиск точного совпадения по часам, минутам или секундам.
isnull    Проверяет, есть ли нулевое поле. Возвращает True или False
regex/iregex    Совпадение регулярных выражений. iregex - версия без учета регистра.

exact/iexact
Поиск exact используется для получения записей с указанным значением. Поиск exact чувствителен к регистру. Для поиска без учета регистра используйте поиск iexact.
Employee.objects.filter(first_name__exact='Jane')
Мы также можем осуществлять поиск по связанным таблицам:
Employee.objects.filter(first_name__exact='Jane', department__name__exact='IT')

contains/icontains
contains позволяет вам проверить, содержит ли строка подстроку. Это эквивалентно следующему оператору - LIKE:
LIKE '%substring%'

Например, следующий код находит сотрудников, чье имя содержит подстроку Bi:
Employee.objects.filter(first_name__contains='Bi')

Запрос возвращает сотрудника с именем Bill.
icontains это не чувствительная к регистру версия метода contains. Таким образом, вы можете использовать icontains чтобы проверить, содержит ли строка подстроку без учета регистра:
Employee.objects.filter(first_name__icontains='j')

in()
Оператор SQL IN возвращает значение True, если значение находится в наборе значений:
field_name IN (v1, v2, ...)
Например, вы можете использовать IN оператор для запроса строк из таблицы hr_employee, который находит значение department_id в списке, подобном этому:
SELECT *
FROM hr_employee
WHERE department_id IN (1,2,3)
В Django вы используете оператор in:
Employee.objects.filter(department_id__in=(1,2))
Обычно вы используете подзапрос с оператором in, а не список литеральных значений.

gt, gte, lt, lte
В Django для выполнения сравнений в запросах к базе данных используются следующие фильтры набора запросов:

gt(больше чем): Этот фильтр выбирает объекты, в которых указанное поле больше заданного значения. Например:
Employee.objects.filter(age__gt=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) больше 30.

lt(меньше чем): этот фильтр выбирает объекты, в которых указанное поле меньше заданного значения. Например:
Employee.objects.filter(age__lt=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) меньше 30.

gte(больше или равно): этот фильтр выбирает объекты, в которых указанное поле больше или равно заданному значению. Например:
Employee.objects.filter(age__gte=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) больше или равно 30.

lte(меньше или равно): Этот фильтр выбирает объекты, в которых указанное поле меньше или равно заданному значению. Например:
Employee.objects.filter(age__lte=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) меньше или равно 30.


startswith / istartswith
Иногда вам нужно проверить, начинается ли строка с подстроки. Например, вы можете найти сотрудников, чье имя начинается с символа "J".
Чтобы сделать это в SQL, вы используете оператор LIKE:
SELECT *
FROM hr_employee
WHERE first_name LIKE 'J%';
Это % подстановочный знак, который соответствует любому количеству символов. И выражение 'J%' соответствует строкам, которые начинаются с символа J и за которыми следует ноль или более символов.
Чтобы запросить данные из Django с помощью оператора LIKE, вы добавляете startswith к имени поля:
field_name__startswith
Например, следующий запрос использует это в методе filter() для поиска сотрудников, чьи имена начинаются с символа J:
Employee.objects.filter(first_name__startswith='J')
Если вы хотите найти сотрудников, чьи имена начинаются с символа J, без учета регистра, вы можете использовать регистронезависимую версию istartswith:
Employee.objects.filter(first_name__istartswith='j')
В этом случае __istartswith для сопоставления используется версия значения в верхнем регистре.

endswith/iendswith
Оператор endswith и iendswith возвращает QuerySet, если значение заканчивается подстрокой. endswith эквивалентен следующему SQL оператору - LIKE:
LIKE '%substring'
Например, в следующем примере endswith используется для поиска сотрудников, чьи имена заканчиваются на ne:
Employee.objects.filter(first_name__endswith='ne')
Метод iendswith, это нечувствительная к регистру версия метода endswith. Например:
Employee.objects.filter(first_name__iendswith='LL')

range()
В SQL вы используете оператор BETWEEN, чтобы проверить, находится ли значение между двумя значениями:
field_name BETWEEN low_value AND high_value
В Django эквивалентом оператора BETWEEN является фильтрация через следующий метод:
Entity.objects.filter(field_name__range=(low_value,high_value))
Например, вы можете найти сотрудников с id от 2 до 4, используя следующий диапазон:
Employee.objects.filter(id__range=(2,4))
Мы также можем использовать данный метод и с датами, например следующий запрос выведет всех сотрудников, которые были созданы в период между двух дат.
Employee.objects.filter(created__range=('2021-12-12', '2023-12-12'))

date()
При необходимости выборки сотрудников, которые были созданы в определенную дату, мы можем использовать следующий метод:
Employee.objects.filter(created__date=date(2023, 7, 14))
Все эти сотрудники были созданы в одну дату, 14.07.2023.

year()
Для выборки сотрудников, созданных в одном году мы можем использовать следующий метод:
Employee.objects.filter(created__year=2023)

iso_year()
Работает аналогично методу year(), принимает год в формате ISO 8601.
month, day, week, week_day, quarter
Метод month принимает точное совпадение месяца:
Employee.objects.filter(created__month=7)
Метод day предназначен для точного совпадения дня.
Метод  week    поиск точного совпадения недели.
Метод week_day   поиск точного совпадения дня недели.
Метод quarter   поиск точного совпадения квартала года.
Все данные методы работают аналогично методу month  и могут использоваться совместно с другими методами, например мы можем вывести всех сотрудников, созданных после 2001 года:
Employee.objects.filter(created__year__gt=2001)
time, hour/minute/second
С помощью данных методов мы можем фильтровать наши значения по времени, часам, минутам и секундам. Например следующий запрос выведет всех сотрудников, созданных после 12:00:
Employee.objects.filter(created__time__gt=datetime.time(12, 00))
Остальные методы(hour, minute, second) работают по такому же принципу и могут использоваться совместно с другими методами.

isnull()
В следующем примере используется isnull для получения сотрудников, у которых нет контактов:
Employee.objects.filter(contact_id__isnull=True)
Сгенерированный запрос использует оператор IS NULL для сравнения contact_id с NULL.
В следующем примере используется isnull для получения всех сотрудников, у которых есть контакты:
Employee.objects.filter(contact_id__isnull=False)
В этом случае сгенерированный запрос использует IS NOT NULL для сравнения значений в столбце contact_id с NULL.

regex/iregex
Данные методы задают регулярное выражение, которому должно соответствовать значение свойства модели. В случае с regex выборка зависит от регистра, а у iregex - не зависит от регистра.
Employee.objects.filter(first_name__regex=r"(hn|ne)$")
В данном случае мы хотим вывести всех сотрудников, у которых значение поля first_name оканчивается на "hn" или "ne".


Агрегатная функция принимает список значений и возвращает одно значение. Наиболее часто используемыми агрегатными функциями являются Count, Max, Min, Avg и Sum. Они предоставляются пакетом django.db.models.

Count()
Функция Count() возвращает количество содержащихся в данном столбце строк. Данная функция принимает столбец, для которого вы хотите получить количество строк. Например, вы можете использовать функцию Count() для получения количества сотрудников:
Employee.objects.aggregate(Count('id'))
Функция Count() использует SQL-функцию COUNT(), которая возвращает количество строк в столбце id таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__count', а в значении будет количество строк в этом столбце.
При необходимости можно задать своё имя ключа, например:
Employee.objects.aggregate(employees=Count('id'))
Так же можно подсчитывать отфильтрованные результаты, например чтобы получить количество сотрудников, чьи имена начинаются с Jo, для этого используется опциональный аргумент filter, который принимает Q-объект:
Employee.objects.aggregate(jo_employees=Count('id', filter=Q(first_name__startswith='Jo')))
Второй опциональный аргумент distinct используется для подсчёта строк только с уникальными значениями, для этого необходимо установить ему значение distinct=True.
Внимание: функция Count() при подсчете использует только не-NULL значения в столбце, кроме случая Count('*'), когда подсчитывается количество всех строк в таблице.

Max()
Функция Max() возвращает максимальное значение в наборе значений. Данная функция принимает столбец, для которого вы хотите получить наибольшее значение.
Например, в следующем примере функция Max() используется для возврата наибольшего возраста сотрудника:
Employee.objects.aggregate(Max('age'))
Функция Max() использует SQL-функцию MAX(), которая возвращает максимальное значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__max', а в значении будет максимальное значение в этом столбце.
Кроме опциональных аргументов filter и distinct, функция Max() принимает ещё два опциональных аргумента default и output_field.
Аргумент default задаёт значение, которое вернёт данная функция, если исходный кверисет будет пустым.
Аргумент output_field задаёт тип поля для возвращаемого значения, по умолчанию используется тот-же тип поля, что и в переданном в функцию поле. Но могут быть ситуации когда в функцию передаётся выражение на основе двух полей разных типов, например DecimalField и FloatField, тогда необходимо указать какой тип поля требуется на выходе функции, например output_field=DecimalField().

Min()
Функция Min() возвращает минимальное значение в наборе значений. Как функция Max(), функция Min() принимает столбец, для которого вы хотите получить наименьшее значение.
В следующем примере функция Min() используется для возврата наименьшего возраста сотрудника:
Employee.objects.aggregate(Min('age'))
Функция Min() использует SQL-функцию MIN(), которая возвращает минимальное значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__min', а в значении будет минимальное значение в этом столбце.
Как и функция Max(), функция Min() принимает опциональные аргументы filter, distinct, default и output_field.

Avg()
Функция Avg() возвращает среднее значение в наборе значений. Она принимает имя столбца и возвращает среднее значение всех значений в этом столбце:
Employee.objects.aggregate(Avg('age'))
Функция Avg() использует SQL-функцию AVG(), которая возвращает среднее значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__avg', а в значении будет среднее значение в этом столбце.
Функция Avg() так-же принимает опциональные аргументы filter, distinct, default и output_field.

Sum()
Функция Sum() возвращает сумму значений. Например, вы можете использовать функцию Sum() для расчета суммы возрастов сотрудников компании:
Employee.objects.aggregate(Sum('age'))
Функция Sum() использует SQL-функцию SUM(), которая возвращает сумму значений в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__sum', а в значении будет сумма значений в этом столбце.
Функция Sum() так-же принимает опциональные аргументы filter, distinct, default и output_field.


В Django вы можете использовать метод annotate() для метода values(), применяя агрегацию к группам следующим образом:
Entity.objects.values('column_2').annotate(value=AGGREGATE('column_1'))
В этом синтаксисе;
values('column_2')– передать в метод values() столбец, который вы хотите сгруппировать.
annotate(value=AGGREGATE('column_1'))– указать, что агрегировать в методе annotate() .
Обратите внимание, что порядок вызова методов values() и annotate() имеет значение. Если вы не вызовете метод values() первым и annotate() вторым, выражение не будет давать агрегированные результаты.


1) Django Group By с примером Count
В следующем примере используются методы values() и  annotate() для получения количества сотрудников по отделам:
Employee.objects.values('department').annotate(head_count=Count('department')).order_by('department')
Сначала сгруппируем сотрудников по отделам с помощью метода values():
values('department')
Далее, применяется функция Count() к каждой группе:
annotate(head_count=Count('department'))
И в конце отсортируйте объекты в наборе QuerySet по отделам:
order_by('department')
За кулисами Django выполняет оператор SELECT с предложением GROUP BY:
SELECT "hr_employee"."department_id",
       COUNT("hr_employee"."department_id") AS "head_count"
  FROM "hr_employee"
 GROUP BY "hr_employee"."department_id"
 ORDER BY "hr_employee"."department_id" ASC
 LIMIT 21

2) Django Group By с примером Min, Max и Avg
В следующем примере несколько агрегатных функций применяются к группам, чтобы получить самый низкий, средний и самый высокий возраст сотрудников в каждом отделе:
Employee.objects.values('department').annotate(min_age=Min('age'), max_age=Max('age'), avg_age=Avg('age')).order_by('department')

3) Группировка Django с примером соединения связанных таблиц
В следующем примере используются методы values() и annotate() для получения количества сотрудников в каждом отделе:
Department.objects.values('name').annotate(head_count=Count('employee'))
Как это работает.
values('name') – группирует отделы по названию.
annotate(head_count=Count('employee')) – подсчитывает сотрудников в каждом отделе.
За кулисами Django использует LEFT JOIN для соединения hr_department таблицы с hr_employee таблицей и применения COUNT() функции к каждой группе.

4) Группировка Django и filter()
Чтобы применить условие к группам, вы используете метод filter(). Например, следующий пример использует метод filter() для получения отдела с количеством сотрудников более 1:
Department.objects.values('name').annotate(head_count=Count('employee')).filter(head_count__gt=1)
За кулисами Django использует SQL предложение HAVING для фильтрации группы на основе условия, которое мы передаем методу filter():
SELECT "hr_department"."name",
       COUNT("hr_employee"."id") AS "head_count"
  FROM "hr_department"
  LEFT OUTER JOIN "hr_employee"
    ON ("hr_department"."id" = "hr_employee"."department_id")
 GROUP BY "hr_department"."name"
HAVING COUNT("hr_employee"."id") > 1



Мета-классы
abstract
Параметр abstract в Meta классе модели Django — это логическое значение, которое указывает, является ли модель абстрактной или нет. Абстрактная модель — это модель, которая предназначена для подкласса других моделей, а не для непосредственного использования.
Когда модель помечена как абстрактная, ее нельзя создать, то есть вы не можете создавать экземпляры модели в своем коде. Однако поля и методы абстрактной модели могут использоваться другими моделями, унаследованными от нее.
Этот abstract параметр удобен для создания повторно используемых компонентов, которые можно использовать в нескольких моделях. Например, вы можете создать абстрактную модель, определяющую общие поля и методы для всех ваших моделей, а затем сделать так, чтобы каждая модель наследовала от абстрактной модели. Это упрощает поддержку вашего кода и гарантирует, что общие функции последовательно реализуются в ваших моделях.

app_label
app_label в Django — это атрибут, который используется для идентификации приложения, к которому принадлежит модель. Он представляет собой строку, содержащую имя приложения (например, myapp).  app_label обычно используется в SQL-запросах, генерируемых Django ORM, для уточнения, к какой базе данных или таблице обратиться.

base_manager_name
В Django, base_manager_name является атрибутом метаданных модели, который определяет имя менеджера, используемого по умолчанию для доступа к объектам данной модели. По умолчанию, если вы не указываете base_manager_name, Django использует менеджер с именем objects.
Когда вы создаёте собственную модель, Django по умолчанию предоставляет менеджер objects. Это стандартный менеджер, который используется для выполнения обычных запросов к базе данных (all(), get(), filter() и т.д.). Однако, бывают ситуации, когда вам нужно определить дополнительные менеджеры для вашей модели, каждый со своей специфической логикой.  base_manager_name указывает, какой из этих менеджеров будет основным и использоваться по умолчанию.

db_table
В Django, db_table — это атрибут метаданных модели, который позволяет явно указать имя таблицы в базе данных, которое будет использоваться для хранения данных этой модели. Если db_table не указан, Django автоматически генерирует имя таблицы на основе имени приложения и имени модели.
По умолчанию, Django создает имя таблицы, используя имя приложения и имя модели, соединенные знаком подчеркивания (_). Например, если у вас есть модель BlogPost в приложении myapp, Django создаст таблицу с именем myapp_blogpost.

db_tablespace
Параметр db_tablespace в Meta классе модели Django представляет собой строку, указывающую имя табличного пространства базы данных, в котором должна храниться таблица базы данных модели.
Табличное пространство — это место на диске, где база данных хранит свои данные. По умолчанию Django будет использовать табличное пространство по умолчанию для базы данных для хранения данных модели. Однако, если вы хотите использовать другое табличное пространство, вы можете использовать опцию db_tablespace в Meta классе модели.
Таблица базы данных модели будет храниться в табличном пространстве с именем my_tablespace вместо табличного пространства по умолчанию. Обратите внимание, что имя табличного пространства, которое вы указываете, должно быть допустимым табличным пространством в вашей базе данных.
Использование табличных пространств может зависеть от базы данных, и этот db_tablespace параметр может быть недоступен или иметь какое-либо влияние на все базы данных. Вам следует обратиться к документации вашей базы данных для получения дополнительной информации об использовании табличных пространств.

default_manager_name
Параметр default_manager_name в Meta классе модели Django представляет собой строку, указывающую имя менеджера по умолчанию для модели.
Менеджер — это интерфейс к базе данных, который позволяет выполнять запросы к базе данных и другие операции с моделью. Django поставляется с менеджером по умолчанию для каждой модели с именем objects. Вы также можете создать собственные менеджеры для модели и указать, какой менеджер должен использоваться по умолчанию для модели, используя параметр default_manager_name в Meta классе.

default_related_name
Параметр default_related_name в Meta классе модели Django указывает имя обратной связи от связанных объектов обратно к модели.
Например, у нас есть Employee модель и Department модель, и каждая из них Employee связана с одним Department, вы можете определить отношение, используя ForeignKey поле в Employee модели
По умолчанию Django создаст обратное отношение с именем employee_set. Это позволяет вам получить доступ к связанным Employee объектам из Department объекта
Однако вы можете изменить имя обратного отношения, используя опцию default_related_name в Meta классе
default_related_name пользовательскую строку, чтобы указать имя обратной связи. Например:
    class Meta:
        default_related_name = 'employee_of_department'
С этой настройкой обратное отношение будет называться employee_of_department

get_latest_by
Параметр get_latest_by в Meta классе модели Django указывает имя поля, используемого для определения самого последнего экземпляра модели.
Например, у нас есть Employee модель с created полем, вы можете указать get_latest_by в Meta классе, чтобы указать, что самым последним Employee экземпляром является экземпляр с последним created:
    class Meta:
        get_latest_by = 'created'
С этим параметром вы можете использовать latest() метод для набора запросов Employee экземпляров, чтобы получить самый последний Employee экземпляр:
Employee.objects.latest()
Обратите внимание, что это get_latest_by влияет только на latest() метод, а не на другие методы набора запросов, такие как order_by(). Если вы хотите заказать набор запросов по другому полю, вы можете использовать order_by() метод:
Employee.objects.order_by('-created')
Вы также можете указать несколько полей в get_latest_by, и в этом случае Django будет использовать первое поле, имеющее ненулевое значение, для определения самого последнего экземпляра.

managed
Параметр managed в Meta классе модели Django указывает, должен ли Django управлять созданием и удалением таблиц базы данных для этой модели.
По умолчанию managed установлено значение True, что означает, что Django создаст таблицу базы данных для модели при запуске команды migrate и удалит таблицу при запуске makemigrations команды с --empty параметром.
В Django параметр managed = False в мета-классе модели (Meta) указывает, что Django не должен управлять жизненным циклом таблицы в базе данных, связанной с этой моделью. Это означает, что Django не будет создавать, изменять или удалять таблицу при выполнении миграций (команды makemigrations и migrate). Обычно это используется для работы с существующими таблицами, созданными вне Django, например, в другой системе или legacy-базе данных.
Вот пример модели с установленным значением managed равным False:
class CustomModel(models.Model):
    # Fields
    class Meta:
        managed = False
Однако Django не ограничивает операции чтения, записи, обновления или удаления данных в таблице через ORM, если модель правильно описывает структуру таблицы. Если в модели описаны поля, которых нет в таблице, или наоборот, обязательные поля таблицы не указаны в модели, это может привести к ошибкам при попытке сохранить данные.

order_with_respect_to
Параметр order_with_respect_to в Meta классе модели Django указывает внешний ключ к другой модели. Порядок экземпляров модели по отношению к связанной модели сохраняется.
Например, если у вас есть Employee модель и Department модель, и каждый Employee экземпляр связан с одним Department экземпляром, вы можете указать order_with_respect_to в Meta классе модели Employee, чтобы указать, что порядок Employee экземпляров должен основываться на их связи с Department экземплярами:
class Department(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.name
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)

    class Meta:
        order_with_respect_to = 'department'

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
Когда установлен order_with_respect_to, предусмотрены два дополнительных метода для извлечения и установки порядка связанных объектов: get_RELATED_order() и set_RELATED_order(), где RELATED - это имя модели в нижнем регистре.
Например, если предположить, что объект Department имеет несколько связанных объектов Employee, возвращаемый список содержит первичные ключи связанных объектов Employee:
Связанные объекты также получают два метода get_next_in_order() и get_previous_in_order(), которые можно использовать для доступа к этим объектам в правильном порядке.
Внутри order_with_respect_to добавляет дополнительное поле/столбец базы данных с именем _order и устанавливает для этого поля параметр ordering модели. Следовательно, order_with_respect_to и ordering не могут использоваться вместе, и порядок, добавленный order_with_respect_to, будет применяться всякий раз, когда вы получаете список объектов этой модели.
Более подробно вы можете почитать в документации - https://docs.djangoproject.com/en/4.2/ref/models/options/#order-with-respect-to

ordering
Параметр ordering в Meta классе модели Django указывает порядок по умолчанию для наборов запросов этой модели. Порядок определяется как список имен полей с необязательным '-' префиксом для указания убывающего порядка.
Например, чтобы упорядочить набор запросов с экземплярами модели Employee по дате их создания в порядке убывания, вы можете указать в классе Meta следующее:
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)
    class Meta:
        ordering = ['-created']
С этим параметром, когда вы извлекаете набор запросов с экземплярами модели Employee, они будут упорядочены по полю created, в порядке убывания:
Вы можете переопределить порядок по умолчанию при получении набора запросов с помощью метода order_by:
Обратите внимание, что параметр ordering влияет только на порядок по умолчанию для наборов запросов. Чтобы сохранить порядок на основе связанной модели, вы можете использовать опцию order_with_respect_to в Meta классе.

permissions
Параметр permissions в классе Meta модели Django указывает список настраиваемых разрешений для модели. Настраиваемые разрешения используются для управления доступом к определенным действиям над экземплярами модели, такими как добавление, изменение или удаление экземпляров.
Каждое разрешение указывается в виде кортежа, где первый элемент представляет собой строку, используемую в качестве кодового имени разрешения, а второй элемент представляет собой удобочитаемое имя разрешения.
Например, чтобы добавить к модели Employee настраиваемые разрешения для добавления и удаления экземпляров, вы можете указать в классе Meta следующее:
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)
    class Meta:
        permissions = [
            ('add_employee', 'Can add Employee'),
            ('delete_employee', 'Can delete Employee'),
        ]
После определения этих настраиваемых разрешений вы можете назначать их пользователям или группам с помощью административного интерфейса Django или программно, используя структуру аутентификации Django.
Обратите внимание, что Django также определяет ряд разрешений по умолчанию для каждой модели, таких как add, view, change и delete, которые автоматически создаются и управляются при создании модели. Этот permissions параметр используется для добавления дополнительных настраиваемых разрешений помимо этих значений по умолчанию.

default_permissions
Параметр default_permissions в классе Meta модели Django указывает набор разрешений по умолчанию, который будет создан для модели. Разрешения по умолчанию в Django включают add, change, view и delete.
По умолчанию Django создает эти разрешения для каждой модели в приложении. Однако вы можете установить default_permissions = [] в классе Meta модели, чтобы отказаться от создания этих разрешений по умолчанию для этой модели.
Например, чтобы отказаться от разрешений по умолчанию для модели Employee, вы можете указать в классе Meta следующее:
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)
    class Meta:
        default_permissions = []
С этим параметром при создании модели Employee разрешения по умолчанию создаваться не будут. Если вам по-прежнему необходимо предоставить разрешение определенным пользователям или группам для выполнения действий с экземплярами этой модели, вы можете использовать параметр permissions в классе Meta для определения настраиваемых разрешений.
Пример использования опции default_permissions в классе Meta модели Django:
default_permissions = ['add', 'change']
В этом примере для модели будут созданы только разрешения add и change по умолчанию. Разрешение delete и view не будет создано, так как оно не включено в список default_permissions.

proxy
Параметр proxy в классе Meta модели Django указывает, следует ли использовать модель в качестве прокси-модели. Прокси-модель — это модель, которая наследует все поля, методы и параметры от другой модели, но может рассматриваться как отдельная модель в Django ORM.
По умолчанию модель в Django не является прокси-моделью. Однако вы можете установить proxy = True в классе Meta модели, чтобы сделать ее прокси-моделью.
Например, чтобы сделать Employee модель прокси-моделью, вы можете указать в классе Meta следующее:
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
class LatestEmployee(Employee):
    class Meta:
        proxy = True
        ordering = ['-created']
В этом примере модель Employee определяет поля, методы и параметры, которые унаследует прокси-модель LatestEmployee. Модель LatestEmployee создается путем установки proxy = True в классе Meta.
Модель LatestEmployee можно использовать так же, как и любую другую модель в Django ORM, но она обращается к тем же данным, которые хранятся в таблице для модели Employee. В этом примере модель LatestEmployee изменяет порядок данных по умолчанию по дате публикации в порядке убывания.
Обратите внимание, что при создании прокси-модели вам не нужно переопределять все поля, методы и параметры базовой модели. Вам нужно только указать различия между прокси-моделью и базовой моделью в классе Meta и других частях определения модели.
Несколько примеров ORM-запросов для моделей Employee и LatestEmployee из предыдущего примера:
Прокси-модель в Django не создается в базе данных как отдельная таблица. Прокси-модель использует таблицу родительской модели и её используют если нужно изменить поведение модели (например добавить другие методы или кастомные менеджеры) без изменения самой структуры базы данных.

required_db_features
Параметр required_db_features в Meta классе модели Django используется для указания минимального набора функций базы данных, необходимых для использования модели. Этот параметр можно использовать для ограничения использования модели определенными базами данных, которые поддерживают определенные функции.

Вот пример использования опции required_db_features:
class MyModel(models.Model):
    data = models.JSONField()
    class Meta:
        required_db_features = ['supports_json_field']
В этом примере модель MyModel использует JSONField для хранения данных JSON. Параметр required_db_features установлен на ['supports_json_field'], чтобы указать, что модель требует json использования функции базы данных. Если пользователь попытается использовать эту модель с серверной частью базы данных, которая не поддерживает поля JSON, Django вызовет исключение NotSupportedError.

required_db_vendor
Параметр required_db_vendor в классе Meta модели Django используется для указания минимального набора поставщиков баз данных, необходимого для использования модели. Этот параметр можно использовать для ограничения использования модели определенными базами данных, предоставляемыми определенными поставщиками.
Например, если у вас есть модель, в которой используется функция, зависящая от поставщика, например PostgreSQL тип данных, зависящий от конкретного поставщика, вы можете установить required_db_vendor значение 'postgresql', чтобы ограничить использование модели только серверной PostgreSQL частью базы данных. Если пользователь попытается использовать модель с другой базой данных, Django вызовет исключение NotSupportedError.
Вот пример использования required_db_vendor опции:
class MyModel(models.Model):
    data = models.ArrayField(models.IntegerField())
    class Meta:
        required_db_vendor = 'postgresql'
В этом примере модель MyModel использует PostgreSQL-specific ArrayField для хранения массивов целых чисел. Параметр required_db_vendor установлен на 'postgresql', чтобы указать, что модель требует PostgreSQL использования серверной части базы данных.

select_on_save
Параметр select_on_save в классе Meta модели Django используется для управления тем, следует ли перезагружать модель из базы данных после операции save. По умолчанию Django перезагружает модель из базы данных после операции save, чтобы обеспечить доступность последних данных. Однако в некоторых случаях вы можете пропустить эту перезагрузку, чтобы повысить производительность.
Параметр select_on_save может быть установлен для False отключения перезагрузки после save операции. Если select_on_save установлено значение False, модель не будет перезагружаться из базы данных после операции save, а данные в модели будут основаны на данных, которые были сохранены в базе данных, а не на последних данных в базе данных.
Вот пример использования опции select_on_save:
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    class Meta:
        select_on_save = False
В этом примере модель MyModel имеет одно поле name. Параметр select_on_save установлен на False отключение перезагрузки после save операции. Это может привести к повышению производительности, но вы должны использовать его с осторожностью, так как это может привести к использованию устаревших данных, если данные в базе данных обновляются вне модели.

indexes
Параметр indexes в классе Meta модели Django позволяет указать пользовательские индексы для полей в вашей модели. Индекс — это функция базы данных, которая помогает повысить производительность запросов, предоставляя быстрый способ поиска строк в таблице на основе значений в одном или нескольких столбцах.
В Django вы можете указать пользовательские индексы, указав список Index экземпляров в indexes опции. Каждый Index экземпляр представляет собой один индекс и может быть определен с помощью полей, которые вы хотите включить в индекс, и любых дополнительных параметров, таких как имя индекса и его уникальность.
Вот пример использования опции indexes:
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    date = models.DateField()
    class Meta:
        indexes = [
            models.Index(fields=['name', 'date']),
        ]
В этом примере модель MyModel имеет два поля name и date. Параметр indexes установлен в список с одним Index экземпляром, который определяет индекс, включающий поля name и date. Это поможет повысить производительность запросов, которые фильтруют как по полю name, так и по полю date.

unique_together
Опция unique_together в Meta классе модели Django позволяет указать набор полей, которые должны быть уникальными вместе. Это означает, что никакие два экземпляра вашей модели не могут иметь одинаковые значения в полях, указанных в файлах unique_together.
В Django вы можете указать уникальные поля вместе, предоставив список списков имен полей в опции unique_together. Каждый список представляет набор полей, которые вместе должны быть уникальными.
Вот пример использования unique_together опции:
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    date = models.DateField()
    class Meta:
        unique_together = [
            ['name', 'date'],
        ]
В этом примере модель MyModel имеет два поля name и date. Параметр unique_together установлен в список с одним списком, который определяет набор полей, которые должны быть уникальными вместе. Это означает, что никакие два экземпляра MyModel не могут иметь одинаковые значения name и date.

index_together
Опция index_together в Meta классе модели Django позволяет указать набор полей, для которых должен быть создан индекс базы данных. Индекс — это структура оптимизации базы данных, которая позволяет быстрее извлекать данные.
В Django вы можете указать поля, которые должны быть проиндексированы вместе, предоставив список списков имен полей в опции index_together. Каждый список представляет собой набор полей, которые должны индексироваться вместе.
Вот пример использования index_together опции:
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    date = models.DateField()
    class Meta:
        index_together = [
            ['name', 'date'],
        ]
В этом примере модель MyModel имеет два поля name и date. Параметр index_together установлен в список с одним списком, который определяет набор полей, которые должны быть проиндексированы вместе c name Это означает, что для полей и будет создан единый индекс базы данных, что позволит быстрее извлекать данные при поиске записей с конкретными значениями name и date.
Данная опция устарела, лучше использовать indexes — это более мощный и гибкий инструмент для создания индексов в Django, который рекомендуется использовать для новых проектов и там, где нужно более детальное управление индексами. index_together подходит для более простых случаев и для поддержки старых проектов.
Код выше эквивалентен этому коду:
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    date = models.DateField()
    class Meta:
        indexes = [
            models.Index(fields=['name', 'date']),
        ]

constraints
Параметр constraints в Meta классе модели Django позволяет указать ограничения, которые должны применяться к полям в модели. Ограничения в Django гарантируют выполнение определенных условий для данных, хранящихся в базе данных.
Вы можете указать ограничения, предоставив список экземпляров django.db.models.CheckConstraint в constraints опции. Каждый экземпляр определяет одно ограничение.
Вот пример использования constraints опции:
from django.db import models
from django.core.exceptions import ValidationError
class MyModel(models.Model):
    name = models.CharField(max_length=100)
    value = models.IntegerField()
    class Meta:
        constraints = [
            models.CheckConstraint(check=models.Q(value__gt=0), name='value_positive'),
        ]
В этом примере модель MyModel имеет два поля name и value. Параметр constraints установлен в список с одним экземпляром CheckConstraint, который определяет ограничение, которое value должно быть больше 0. Это ограничение будет применяться к полю value в базе данных, и любая попытка сохранить запись с отрицательным value результатом приведет к ошибке ValidationError.

verbose_name
Параметр verbose_name в Meta классе модели Django позволяет указать удобочитаемое имя модели, которое используется в различных местах фреймворка Django, например, в административном интерфейсе или в сообщениях об ошибках. По умолчанию подробное имя модели представляет собой версию имени модели, написанную с заглавной буквы.
Вот пример использования verbose_name опции:
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    publication_date = models.DateField()
    class Meta:
        verbose_name = 'My Book'
В этом примере модель Book имеет три поля: title, author, и publication_date. Для параметра verbose_name установлено значение 'My Book', которое будет использоваться в качестве удобочитаемого имени модели в различных местах фреймворка Django. Например, если вы используете интерфейс администрирования Django, вы увидите My Book имя модели вместо Book.

verbose_name_plural
Параметр verbose_name_plural в классе модели Django Meta используется для указания формы множественного числа удобочитаемого имени модели. Это имя используется в различных местах среды Django, например, в административном интерфейсе или в сообщениях об ошибках.
Вот пример использования verbose_name_plural опции:
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    publication_date = models.DateField()
    class Meta:
        verbose_name = 'My Book'
        verbose_name_plural = 'My Books'
В этом примере модель Book имеет три поля: title, author и publication_date. Параметр verbose_name установлен на 'My Book', а verbose_name_plural параметр установлен на 'My Books'. Эти имена будут использоваться в качестве удобочитаемых имен для модели и ее экземпляров в различных местах фреймворка Django. Например, если вы используете интерфейс администрирования Django, вы увидите My Books имя коллекции экземпляров модели Book, а не Books.

Имя диспетчера моделей Django
По умолчанию Manager класс добавляет менеджера к каждой вызываемой модели objects, но если вы хотите использовать объекты в качестве поля модели или хотите использовать другое имя менеджера модели вместо объектов, вам необходимо переименовать его в соответствии с моделью.
Чтобы переименовать менеджер моделей в Django, вам нужно создать экземпляр класса Manager в модели Django.
Диспетчер моделей Django по умолчанию
Чтобы изменить менеджер моделей Django по умолчанию, вам необходимо создать экземпляр класса models.Manager() внутри модели Django.  В приведенной ниже модели Django показано, как я меняю менеджер модели по умолчанию с objects на persons.
class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.SmallIntegerField(null=True)
    created = models.DateTimeField(default=timezone.now)
    work_experience = models.SmallIntegerField(default=0)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)
    persons = models.Manager()
    def __str__(self):
        return f'{self.first_name} {self.last_name}'
Теперь вы можете видеть в приведенном выше примере, что мы успешно изменили диспетчер моделей, поэтому мы не можем использовать Employee.objects оператор для взаимодействия с базой данных. Когда мы попытаемся использовать его, Employee.objects будет сгенерировано исключение AttributeError.

Есть две причины, которые могут расширить класс Manager: добавить дополнительный метод менеджера или изменить исходный QuerySet, возвращаемый менеджером.
Добавление дополнительного метода менеджера
Здесь я собираюсь добавить пользовательский метод менеджера, который отвечает за получение всех сотрудников возрастом старше 30 лет из таблицы Employee. Чтобы добавить дополнительный метод менеджера, мы должны расширить класс и определить метод внутри того класса, который мы хотим создать models.Manager




ИНДЕКСЫ БАЗЫ ДАННЫХ
Индексирование базы данных — это создание специальной структуры данных, которая ускоряет поиск данных в таблице. Представьте себе телефонный справочник: вместо того, чтобы просматривать каждую страницу в поисках имени, вы используете алфавитный указатель (индекс). Индекс в базе данных работает аналогично.

Индекс — это отдельная структура данных (обычно B-дерево или его вариации), содержащая указатели на строки в таблице. Вместо сканирования всей таблицы для поиска данных по определенному критерию, система управления базами данных (СУБД) использует индекс для быстрого поиска соответствующих указателей и доступа к нужным строкам.

Преимущества индексирования:
Ускорение запросов: Самое главное преимущество — значительное ускорение выполнения запросов, особенно тех, которые используют операторы WHERE, ORDER BY, и JOIN.
Улучшение производительности: Поскольку СУБД не вынуждена сканировать всю таблицу, общая производительность базы данных повышается.
Уменьшение времени отклика: Пользователи получают результаты запросов быстрее.
Недостатки индексирования:
Замедление операций записи (INSERT, UPDATE, DELETE): При добавлении, изменении или удалении данных, СУБД также должна обновить индекс, что может немного замедлить эти операции.
Дополнительный расход места: Индексы занимают дополнительное пространство на диске.
Избыточность: Индексы содержат дублированную информацию из таблицы, что приводит к некоторой избыточности данных.
.
B-дерево (B-tree):
Описание: Один из наиболее распространенных типов индексов, основанный на самобалансирующемся дереве. Он эффективно поддерживает как поиск по равенству, так и диапазонный поиск.
Преимущества: Обеспечивает высокую производительность поиска по диапазону, а также точное совпадение. Обычно имеет высокую эффективность в самых разных сценариях.
Недостатки: Может иметь некоторую избыточность в хранении данных.
Применение: Подходит для большинства типов данных и задач поиска, включая поиск по численным, текстовым и строковым полям

2. Hash-индекс:
Описание: Использует хеш-функцию для преобразования ключей в адреса в таблице.
Преимущества: Очень быстрый для точного совпадения. Отлично подходит для сравнения по равенству.
Недостатки: Не поддерживает диапазонный поиск. Неэффективен при сравнениях >=, <=, BETWEEN. Может потребовать дополнительных вычислений в некоторых случаях.
Применение: Лучше всего подходит для ситуаций, где нужен только поиск по равенству, например, для поиска по уникальным идентификаторам.

3. Full-text индекс (полнотекстовый):
Описание: Оптимизирован для поиска слов и фраз внутри текстовых полей. Использует алгоритмы, позволяющие быстро находить соответствующие фрагменты текста.
Преимущества: Обеспечивает эффективную работу с полным текстом, например, в поиске по ключевым словам.
Недостатки: Может быть сложнее настроить и оптимизировать для специфических запросов, чем B-дерево.
Применение: Широко используется в системах поиска, для поиска внутри длинных текстовых полей (например, описаний продуктов, статей).

4. Spatial индекс:
Описание: Специально разработан для пространственных данных (геоданные, координаты). Обычно основаны на B-дереве, но с дополнительной информацией для геометрических операций.
Преимущества: Обеспечивает эффективную работу с запросами на пространственное покрытие, пересечение, близость и т.д.
Недостатки: Не подходит для обычных негеометрических поисков.
Применение: Широко используется в системах геоинформатики, картах, системах управления пространственными данными.

5. Bitmap индекс:
Описание: Использует битовые карты для хранения информации о наличии значений в столбце. Эффективен, когда столбец имеет ограниченное количество уникальных значений (например, “пол”, “статус”).
Преимущества: Очень эффективные при запросах по определенным категориям, когда требуется найти записи по одному или небольшому числу значений.
Недостатки: Неэффективен для диапазонного поиска и поиска по множеству значений.
Применение: Часто используется в специализированных системах, когда есть ограниченный набор уникальных значений.

6. Функциональный индекс:
Описание: Индекс вычисляется на основе выражений над данными столбцов. Вычисление происходит в процессе создания индекса, не в момент выполнения запроса.
Преимущества: Ускоряет запросы, которые используют сложные выражения над столбцами.
Недостатки: Могут быть дорогостоящими в плане вычислений при создании.
Применение: Используется в случаях, когда вам нужно часто использовать сложные условия или вычисления в WHERE-оператор.
Важно отметить, что конкретные типы индексов и их реализация могут отличаться в разных СУБД (PostgreSQL, MySQL, Oracle, SQL Server и т.д.). Изучение документации конкретной СУБД поможет понять особенности и оптимальный подход к созданию индексов.

Установка Debug Toolbar в Django
1) Установка библиотеки
Для установки django-debug-toolbar, используем команду pip install. Запустите следующий код в терминале/оболочке ОС:
pip install django-debug-toolbar
2) Добавление в INSTALLED_APPS
В settings.py добавьте следующую строку в раздел INSTALLED_APPS.
Проверьте, что бы debug_toolbar был добавлен после django.contrib.staticfiles.
INSTALLED_APPS = [
    ...
    'debug_toolbar',
]
Также убедитесь, что в файле settings.py присутствует следующая строка STATIC_URL = '/static/'. Обычно она находится в конце модуля и не требует добавления.
Чтобы использовать Debug Toolbar, мы должны импортировать его пути. Следовательно, в urls.py добавьте код:
from django.contrib import admin
from django.urls import path, include
from debug_toolbar.toolbar import debug_toolbar_urls
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('hr.urls')),
] + debug_toolbar_urls()
4) Подключение MiddleWare
Добавьте middleware панели инструментов debug_toolbar.middleware.DebugToolbarMiddleware, в список MIDDLEWARE в settings.py:
...
MIDDLEWARE = [
    ...
    'debug_toolbar.middleware.DebugToolbarMiddleware',
]
...
5) Упоминание INTERNAL_IPS
Django Debug Toolbar отображается только в том случае, если в списке INTERNAL_IPS есть IP приложения. Для разработки на локальном компьютере добавьте в список IP 127.0.0.1.
# debug_tool/settings.py
...
INTERNAL_IPS = [
    '127.0.0.1',
]



Следующим шагом нам необходимо сгенерировать наших работников для модели Employee фейковыми данными.
Для этого установим Faker:
pip install faker

>>> from faker import Faker as fk
>>> the_fake = fk()
>>> for i in range(10000):
...     a = Employee(first_name = the_fake.first_name(), last_name = the_fake.last_name(), about=the_fake.text())
...     a.save()
...

Индекс B-Tree
По умолчанию PostgreSQL предоставляет нам очень простой, но эффективный тип индекса - индекс B-дерева. Этот тип индекса является наиболее распространенным в использовании. Он достигает своей цели, создавая древовидную структуру блоков, содержащих ключевые значения в порядке возрастания. Каждый из этих блоков ссылается на еще два дочерних блока, где левые боковые клавиши сохраняют значение меньше, чем текущие клавиши, а правые - больше, чем текущие. Таким образом, поиск значений внутри индекса подходит к простым расчетам сравнения. B-дерево также может обрабатывать запросы равенства и диапазона данных, которые можно отсортировать по порядку.

Hash Index
Иногда мы можем столкнуться с необходимостью выполнить "обратный поиск". В нашем случае это будет поиск about на основе значения. Выполнение такого запроса без индекса редко является оптимальным, добавление индекса в поле about значительно улучшит производительность этого представления.
Быстрым и простым решением этой проблемы является использование функции PostgreSQL под названием Hash Index. Он работает путем применения хеш-функций к значениям столбцов и присвоения этих значений контейнерам, называемым "бакетами". Это наиболее эффективно, когда данные в столбце почти уникальны. Мы можем использовать его, импортируя пакет PostgreSQL. К счастью, он доступен в Django.
Резюме:
Уменьшает размер индекса.
В конкретных сценариях он оптимизирует скорость.
Отлично подходит для больших почти уникальных значений.
Неэффективен, когда данные столбцов состоят из похожих значений.

Индекс диапазона блоков (BRIN)
Индекс BRIN расшифровывается как "Block Range Index" (Индекс диапазона блокировки) и группирует значения в столбце в диапазоны страниц JSON. Эта функция PostgreSQL лучше всего работает, когда данные естественным образом сортируются на диске, что не совсем соответствует нашему примеру, у нас дата создания у всех почти одинаковая. Но главное преимущество этой ситуации заключается в том, что они отсортированы в нашей таблице по возрастанию.
Резюме:
Значительно уменьшает размер индекса.
Отлично подходит для любых дат или естественно растущих значений в столбце.
Может быть бесполезно, когда данные естественным образом не сортируются на диске.
Не оптимизирует скорость в сравнении с другими индексами.


Благодаря таким движкам, как PostgreSQL, нам предоставляется множество полезных типов индексов, которые могут удовлетворить наши потребности, в то время как большинство из них просты в использовании и легко интегрируются с веб-фреймворками, такими как Django.
И последнее, но не менее важное: ответственные разработчики должны помнить, что введение любого нового индекса негативно повлияет на скорость сохранения новых записей в таблице базы данных (например, выполнение запроса INSERT).
Всегда есть баланс, который нужно найти, чтобы найти идеальное золотое среднее между чтением и созданием данных. Тем не менее, всегда стоит использовать индексы, так как их полезность невозможно переоценить.
Дополнительные ресурсы
Следующие ниже ресурсы предоставляют дополнительную информацию, относящуюся к темам, затронутым в этом разделе:
Официальная документация PostgreSQL: https://www.postgresql.org/docs/current/indexes.html.
Индексы PostgreSQL в документации Django: https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/indexes/.
Введение хэш-индексов в PostgreSQL: https://hakibenita.com/postgresql-hash-index.
Документация Django: https://docs.djangoproject.com/en/5.0/.
Исходный код Django: https://github.com/django/django.
Документация Python: https://docs.python.org/3/.

python -Xutf8 manage.py dumpdata --indent=2 --exclude contenttypes --exclude social_django -o db.json

Разработка через тестирование
Эта конструкция if __name__ == '__main__': используется для проверки, запущен ли файл напрямую или импортирован в другой модуль.
1. Проверка __name__ == '__main__'
В Python у каждого файла есть специальная переменная __name__.
Если файл запущен напрямую, то __name__ принимает значение '__main__'.
Если файл импортирован в другой модуль, __name__ будет равно имени файла без .py


На уровне модуля
Предположим, у вас есть тестовый модуль с именем test_my_module.py.
В test_my_module.py, функции setUpModule() и tearDownModule() являются фикстурами уровня модуля.
Функция setUpModule() запускается перед всеми методами тестирования в тестовом модуле.
Функция tearDownModule() запускается после всех методов в тестовом модуле.
Если вы запустите тест:
python -m unittest -v
То получите следующий вывод:
В этом примере setUpModule() функция запускается перед всеми методами тестирования и tearDownModule() функция запускается после всех методов тестирования.

На уровне класса
setUpClass() и tearDownClass() являются фикстурами уровня класса:
setUpClass() выполняется перед всеми тестовыми методами класса.
tearDownClass() выполняется после всех тестовых методов класса.

На уровне метода
setUp() и tearDown() являются фикстурами уровня метода:
setUp() выполняется перед каждым тестовым методом в тестовом классе.
tearDown() выполняется после каждого тестового метода в тестовом классе.

Утверждения 
Внутри тестового метода у нас есть утверждения, используемые для оценки двух операндов, чтобы увидеть, соответствует ли значение слева значению справа. Если они совпадают, мы имеем успешное утверждение. Если это не соответствует, у нас есть неудачное утверждение.
Вот несколько утверждений:
assertIsNone: Это утверждение проверяет, имеет ли операнд значение None.
assertIsInstance: Это утверждение проверяет, является ли операнд в левой части экземпляром операнда в правой части.
assertEqual: Это утверждение проверяет, соответствует ли операнд в левой части операнду в правой части.
assertRaises: Это утверждение проверяет, вызывает ли рассматриваемый операнд конкретное исключение. Это может быть полезно, если мы ожидаем, что конкретная тестовая функция вызовет конкретное исключение.
assertIn: Это утверждение проверяет, содержится ли элемент операнда в левой части в элементе операнда в правой части. Например, мы можем проверить, соответствует ли вывод HTML тому, что мы ожидаем.
assertTrue: Это утверждение проверяет, является ли рассматриваемый операнд True.
assertFalse: Это утверждение проверяет, утверждает ли рассматриваемый операнд значение False.

resolve функцию, которая используется для преобразования определенного URL-адреса в view функцию. Поэтому он идет по пути аргументации.

def test_book_form(self):
        form = self.response.context.get('add_book_form')
        self.assertIsInstance(form , AddBookForm)
        self.assertContains(self.response, 'csrfmiddlewaretoken')
Сначала мы получаем саму форму. Мы называем его add_book_form. Получив это, мы сохраняем его в переменной с именем form и проверяем, что мы используем тот же экземпляр формы в нашем шаблоне, который в данном случае является домашней страницей.
Мы проверяем, включен ли токен CSRF. Следует отметить, что он должен быть включен в любую форму, обрабатывающую запрос POST.

def test_bootstrap_class_used_for_default_styling(self):
	form = self.response.context.get('add_book_form')
	self.assertIn('class="form-control"', form.as_p())
Цель следующего тестового метода, который можно увидеть в этой строке, — убедиться, что мы правильно стилизовали форму. Мы будем использовать bootstrap в качестве стиля по умолчанию в будущем. Для этого мы ищем form-control класс в полях ввода формы.

widgets = {
    'title': forms.TextInput(attrs={
        'class': 'form-control'
    }),
    'ISBN': forms.TextInput(attrs={
        'class': 'form-control'
    }),
    'author': forms.TextInput(attrs={
        'class': 'form-control'
    }),
    'price': forms.NumberInput(attrs={
        'class': 'form-control'
    }),
    'availability': forms.Select(attrs={
        'class': 'form-control'
    })
} 
Атрибут класса form-control добавляется в HTML-форму. Это поможет нам настроить форму позже, чтобы она выглядела презентабельно.

form
Метод save()
У каждого класса ModelForm также есть метод save(). Этот метод создаёт и сохраняет объект базы данных из данных, привязанных к форме. Подкласс ModelForm может принимать существующий экземпляр модели в качестве ключевого аргумента instance; если он указан, метод save() обновит этот экземпляр. Если он не указан, метод save() создаст новый экземпляр указанной модели:
>>> from myapp.models import Article
>>> from myapp.forms import ArticleForm
# Create a form instance from POST data.
>>> f = ArticleForm(request.POST)
# Save a new Article object from the form's data.
>>> new_article = f.save()
# Create a form to edit an existing Article, but use
# POST data to populate the form.
>>> a = Article.objects.get(pk=1)
>>> f = ArticleForm(request.POST, instance=a)
>>> f.save()

Кажется, что модификация, которую мы сделали в файле views.py, теперь связана с подключением к базе данных. Большинство тестов, которые мы написали на предыдущих уроках, использовали класс SimpleTestCase.
До этого момента, несмотря на то, что мы взаимодействовали с нашим представлением, тест все еще выполнялся успешно. Однако, поскольку мы ввели соединение с базой данных в представлении, нам нужно обновить все тестовые классы, чтобы использовать класс TestCase.


Разрешения в Django
Аутентификация (Authentication):
Цель: Установить личность пользователя. Проверить, кто именно пытается получить доступ.
Вопрос: “Кто ты?”
Процесс: Пользователь предоставляет свои учетные данные (например, имя пользователя и пароль, токен доступа, биометрические данные). Система проверяет эти данные, с данными, которые хранятся в базе данных. Если данные верны, пользователь считается аутентифицированным.
Результат: Успешная аутентификация подтверждает, что пользователь является тем, за кого себя выдает. Система выдает пользователю некоторое подтверждение аутентификации (например, сессионный куки, токен JWT).
Пример: Вход в систему с помощью имени пользователя и пароля. Подтверждение личности с помощью двухфакторной аутентификации (например, код из SMS).

Авторизация (Authorization):
Цель: Определить, какие действия аутентифицированный пользователь имеет право выполнять. Проверить, что именно пользователь может делать.
Вопрос: “Что ты можешь делать?”
Процесс: После успешной аутентификации система проверяет, имеет ли пользователь разрешение на доступ к запрашиваемому ресурсу и выполнение запрашиваемого действия. Эта проверка часто основана на ролях, правах доступа или политиках безопасности.
Результат: Если пользователь авторизован, ему предоставляется доступ к ресурсу. Если нет, ему будет отказано в доступе.
Пример: Администратор имеет полный доступ к системе, а обычный пользователь — только к своей учетной записи. Пользователь может просматривать, но не может редактировать определенные данные.

А что если нужно предоставить доступ к редактированию только некоторых постов? Например, как разрешить пользователю Василию редактировать только первый и третий пост из четырех, оставляя остальные недоступными?
Для управления разрешениями на уровне объектов мы и будем использовать библиотеку django-guardian.
Продолжим работу в нашем проекте и приложении blog. И установим библиотеку django-guardian:
pip install django-guardian
Добавим django_guardian в наш проект в файле settings.py. Также необходимо добавить бэкенды для авторизации, которые использует django_guardian:
INSTALLED_APPS = (
 #другие приложения
 'blog',
 'guardian',
)
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend', # бэкенд Django по умолчанию
    'guardian.backends.ObjectPermissionBackend', # бэкенд django_guardian
)

Далее мы настроим права доступа к постам через административную панель Django, добавив возможность назначать конкретного пользователя, уполномоченного редактировать каждый отдельный пост.
Добавим в файл admin.py такой код:
from django.contrib import admin
from blog.models import Post
from guardian.admin import GuardedModelAdmin
class PostAdmin(GuardedModelAdmin):
    list_display = ('name',)
admin.site.register(Post, PostAdmin)
Затем создадим первый пост (необходимо сохранить его, нажав для этого кнопку Save and continue editing), а затем, для пользователя Василий, мы разрешим его редактирование:
Далее нажимаем в правом верхнем углу кнопку OBJECT PERMISSIONS, затем выбираем пользователя Василий и нажимаем кнопку Manage user:
Как вы видите, для пользователя Василий для объекта первый пост мы задали разрешение Can change post

Это всё можно сделать и программно. Давайте добавим вторую статью и для пользователя Василия укажем, разрешение change_post:
from django.contrib.auth.models import User
from guardian.models import UserObjectPermission
from blog.models import Post
vasiliy = User.objects.get(username='Василий')
second_post = Post.objects.create(name='Второй пост', content='Этот пост может менять Василий')
UserObjectPermission.objects.assign_perm('change_post', vasiliy, obj=second_post)

Для создания группы вам понадобится Group модель из django.contrib.auth.models.
импортируем необходимые модули:
from django.contrib.auth.models import Group, User, Permission
from django.contrib.contenttypes.models import ContentType
from django.shortcuts import get_object_or_404
from blog.models import Post
Далее создадим новые группы для пользователей:
author_group, created = Group.objects.get_or_create(name="Author")
editor_group, created = Group.objects.get_or_create(name="Editor")
publisher_group, created = Group.objects.get_or_create(name="Publisher")
Затем разрешение может быть назначено модели через атрибут post_permissions.

Что такое ContentType?
Это модель Django, которая хранит информацию обо всех моделях в проекте
Каждая модель в базе данных имеет соответствующий объект ContentType
Это позволяет создавать обобщенные связи между моделями
Как работает get_for_model():
Принимает класс модели (в данном случае Post)
Возвращает объект ContentType, связанный с этой моделью

Если объект еще не существует в базе, он создается автоматически
post_content_type = ContentType.objects.get_for_model(Post)
post_permission = Permission.objects.filter(content_type=post_content_type)
Выполним следующие команды, которые нам покажут все разрешения для модели Post:
Выполним следующий запрос, чтобы назначить нашим группам необходимые права:
for perm in post_permission:
    if perm.codename == "delete_post":
        publisher_group.permissions.add(perm)
    elif perm.codename == "change_post":
        editor_group.permissions.add(perm)
        publisher_group.permissions.add(perm)
    else:
        author_group.permissions.add(perm)
        editor_group.permissions.add(perm)
        publisher_group.permissions.add(perm)
Далее создадим нового пользователя и добавим его в группу авторов:
user = User.objects.create_user(username="Максим", password="test", email="test@user.com")
author_group = Group.objects.get(name="Author")
Далее выберем пользователя с именем Максим и добавим ему эту группу:
user = User.objects.get(username="Максим")
user.groups.add(author_group)
Осталось только проверить его права, Как мы помним, группа Author может просматривать и добавлять сообщения:
user = get_object_or_404(User, pk=user.id)
print(user.has_perm("blog.delete_post"))
print(user.has_perm("blog.change_post"))
print(user.has_perm("blog.view_post"))
print(user.has_perm("blog.add_post"))



HTMX на основе CRUD проекта
HTMX — это библиотека JavaScript, которая позволяет вам использовать HTML для создания интерактивных веб-приложений без использования полноценного фреймворка JavaScript, такого как React, Vue или Angular. Она делает это, добавляя атрибуты к вашим существующим элементам HTML, которые позволяют браузеру взаимодействовать с сервером, используя HTTP-запросы (GET, POST, PUT, DELETE и др.). Вместо полной перезагрузки страницы, HTMX обновляет части страницы асинхронно, используя XMLHttpRequest (или fetch).

Как HTMX работает:
HTMX добавляет новые атрибуты к тегам HTML, которые определяют поведение. Эти атрибуты указывают HTMX, как обрабатывать события (например, клик, отправка формы) и как обновлять содержимое страницы на основе ответа от сервера. Основные атрибуты:
hx-get, hx-post, hx-put, hx-delete, hx-patch: Эти атрибуты указывают HTMX, какой HTTP-метод использовать для отправки запроса на сервер. Значением атрибута является URL.
hx-target: Указывает элемент на странице, куда будет вставлен ответ от сервера. Если не указан, то ответ вставляется в текущий элемент.
hx-swap: Определяет, как заменить содержимое целевого элемента (hx-target). Возможные значения: innerHTML, outerHTML, beforebegin, afterbegin, beforeend, afterend.
hx-include: Указывает фрагменты ответа, которые нужно вставить.
hx-exclude: Указывает фрагменты ответа, которые нужно исключить.
hx-trigger: Указывает, какое событие должно инициировать запрос. По умолчанию, это событие click.
hx-headers: Позволяет добавлять HTTP-заголовки к запросу.
hx-confirm: Позволяет добавить диалог подтверждения перед отправкой запроса.
hx-encoding: Указывает кодировку (например, multipart/form-data для файлов).

Подключим его, для этого отредактируем файл шаблона templates/base.html, добавив в начало следующий код:
<body hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'>        
И в конце:
    <script src="https://unpkg.com/htmx.org@1.9.4"></script>
</body>
Подключим кнопку Add book, в файле шаблона templates/partial_create_book_form.html отредактируем код кнопки:
                            <!-- Кнопка "Add book" -->
                            <button type="submit"
                                    class="disbtn"
                                    hx-post="{% url 'create_book' %}"
                                    hx-target="#book-list"
                                    hx-swap="beforeend" >
                                Add book
                            </button>
HTMX атрибуты для кнопки Add book:
hx-post="{% url 'create_book' %}" определяет адрес запроса /create_book/ и тип запроса - POST.
hx-target="#book-list" задаёт целевой элемент, куда будет добавлен ответ, в данном случае это <tbody id="book-list">.
hx-swap="beforeend" указывает как добавлять ответ в целевой элемент, в данном случае ответ будет добавлен после последнего дочернего элемента - после последней строки таблицы будет вставлена новая строка добавленной книги.
После нажатия данной кнопки, данные формы будут отправлены, и в таблицу будет добавлен ответ - строка новой книги.


В файл шаблона templates/base.html добавим код, который будет очищать текстовые поля формы после отправки:
<script src="https://unpkg.com/htmx.org@1.9.4"></script>
    <script>
        function cngElementsAtr(cls, atr, val){
            var elems = document.getElementsByClassName(cls);
            for(var i = 0; i < elems.length; i++) {
                elems[i][atr] = val;
            }
        }
        document.body.addEventListener('htmx:afterRequest', (event) => {
            path_str = event.detail.pathInfo.requestPath;
            if(path_str.includes('create_book')){
                cngElementsAtr('clrtxt', 'value', '');
            }
        });
    </script>
</body>
Данный код работает так: после выполнения AJAX запроса, мы получаем путь из запроса в переменную path_str и ищем в нём строку create_book.
Если в пути есть данная строка, то тогда будет вызвана функция cngElementsAtr('clrtxt', 'value', ''), которая установит значение атрибута value равное пустой строке для всех элементов с классом clrtxt, то есть произойдёт очистка текстовых полей в форме добавления книги.


hx-get="{% url 'update_book_details' book.id %}" определяет адрес запроса /update_book_details/<id книги>/ и тип запроса - GET.
hx-target="closest tr" задаёт целевой элемент, куда будет добавлен ответ, в данном случае это будет ближайший элемент tr - текущая строка таблицы.
hx-swap="outerHTML" указывает как добавлять ответ в целевой элемент, в данном случае ответом будет заменён весь целевой элемент.
После нажатия данной кнопки, текущая строка таблицы будет заменена на ответ - строку с формой редактирования книги.

Подключим кнопки Save и Cancel в шаблоне templates/partial_book_update_form.html:
                            <!-- Кнопка "Save" -->
                            <button type="submit"
                                    hx-post="{% url 'update_book_details' book.id %}"
                                    hx-target="closest tr"
                                    hx-swap="outerHTML"
                                    hx-include="closest tr" >
                                Save
                            </button>
                            <!-- Кнопка "Cancel" -->
                            <button hx-get="{% url 'book_detail' book.id %}"
                                    hx-target="closest tr"
                                    hx-swap="outerHTML" >
                                Cancel
                            </button>  
HTMX атрибуты для кнопки Save:
hx-post="{% url 'update_book_details' book.id %}" определяет адрес запроса /update_book_details/<id книги>/ и тип запроса - POST. По этому адресу будут отправлены данные формы редактирования книги.
hx-include="closest tr" позволяет включить дополнительные значения элементов в запрос AJAX, в данном случае это ближайший элемент tr, а так-как атрибут hx-include наследуется, то в запрос будут включены значения элементов - текстовых полей.
После нажатия данной кнопки будут отправлены данные формы, и строка с формой редактирования будет заменена на ответ - строку текущей книги, с изменёнными данными.
HTMX атрибуты для кнопки Cancel:
hx-get="{% url 'book_detail' book.id %}" определяет адрес запроса /book_detail/<id книги>/ и тип запроса - GET.
После нажатия данной кнопки, строка с формой редактирования будет заменена на ответ - строку текущей книги.

Добавим в шаблон templates/base.html код для блокирования всех кнопок, кроме кнопок формы редактирования -  Save и Cancel, при редактировании данных книги:
    <script>
        function cngElementsAtr(cls, atr, val){
            var elems = document.getElementsByClassName(cls);
            for(var i = 0; i < elems.length; i++) {
                elems[i][atr] = val;
            }
        }
        document.body.addEventListener('htmx:afterRequest', (event) => {
            path_str = event.detail.pathInfo.requestPath;
            if(path_str.includes('create_book')){
                cngElementsAtr('clrtxt', 'value', '');
            }else if(path_str.includes('update_book_details')){
                if(event.detail.requestConfig.verb === 'get'){
                    cngElementsAtr('disbtn', 'disabled', true);
                }else{
                    cngElementsAtr('disbtn', 'disabled', false);
                }
            }else if(path_str.includes('book_detail')){
                cngElementsAtr('disbtn', 'disabled', false);
            }
        });
    </script>
Данный код работает так: если в пути из запроса есть строка update_book_details и тип запроса был GET(была нажата кнопка Edit), то тогда будет вызвана функция cngElementsAtr('disbtn', 'disabled', true).
Эта функция установит значение атрибута disabled равное true для всех элементов с классом disbtn, то есть произойдёт блокирование всех кнопок, кроме кнопок формы редактирования данных книги.
Если запрос был не типа GET, например POST, или в пути есть строка book_detail(была нажата кнопка Save или кнопка Cancel), то тогда будет вызвана функция cngElementsAtr('disbtn', 'disabled', false), которая разблокирует кнопки.


Теперь добавим функционал для удаления книг.
Добавим функцию-представление для удаления книги delete_book() в файл представлений books/views.py:
@require_http_methods(['DELETE'])
def delete_book(request, pk):
    book = get_object_or_404(Book, pk=pk)
    book.delete()
    return HttpResponse()
HTMX атрибуты для кнопки Delete:
hx-delete="{% url 'delete_book' book.id %}" определяет адрес запроса /delete_book/<id книги>/ и тип запроса - DELETE.
hx-confirm="Are you sure you wish to delete this book?" выводит соответствующее подтверждение перед запросом.
После нажатия данной кнопки будет удалена текущая книга, и её строка в таблице будет заменена на ответ - пустую строку.


Последним шагом добавим возможность устанавливать статус книги - прочитана она или нет.
Добавим функцию изменения статуса книги update_book_status() в файл books/views.py:
@require_http_methods(['PATCH'])
def update_book_status(request, pk):
    book = get_object_or_404(Book, pk=pk)
    book.read = not book.read
    book.save()
    return render(request, 'partial_book_detail.html', {'book': book})
Подключим кнопки статуса книги Read и Unread в файле шаблона templates/partial_book_detail.html:
                            <!-- Ячейка состояния -->
                            <td>
                                <!-- Кнопка "Read/Unread" -->
                                <button class="disbtn"
                                        hx-patch="{% url 'update_book_status' book.id %}"
                                        hx-target="closest tr"
                                        hx-swap="outerHTML" >
                                    {% if book.read %}Read{% else %}Unread{% endif %}
                                </button>
                            </td>
HTMX атрибуты для кнопок Read и Unread:
hx-patch="{% url 'update_book_status' book.id %}" определяет адрес запроса /update_book_status/<id книги>/ и тип запроса - PATCH.
Теперь подключим стрелочки сортировки в заголовке таблицы, в файле шаблона templates/base.html:
                    <thead>
                    <tr>
                        <!-- Заголовки столбцов таблицы -->

                        <!-- Заголовок номера книги -->
                        <th scope="col" style="width: 10%">
                            <small>
                                No.
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='id' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='id' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок названия книги -->
                        <th scope="col" style="width: 26%">
                            <small>
                                Title
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='title' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='title' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок автора книги -->
                        <th scope="col" style="width: 26%">
                            <small>
                                Author
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='author' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='author' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок цены книги -->
                        <th scope="col" style="width: 11%">
                            <small>
                                Price ($)
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='price' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='price' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок статуса книги -->
                        <th scope="col" style="width: 11%">
                            <small>
                                Status
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='read' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='read' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>

                    </tr>
                    </thead>
HTMX атрибуты для кнопок сортировки ⇓ и ⇑:
hx-get="{% url 'book_list_sort' filter='id' direction='ascend' %} определяет адрес запроса
/book_list_sort/id/ascend/ и тип запроса - GET, сортировка по-возрастанию.
hx-get="{% url 'book_list_sort' filter='id' direction='descend' %} определяет адрес запроса
/book_list_sort/id/descend/ и тип запроса - GET, сортировка по-убыванию.
Ответ AJAX запроса будет добавлен в целевой элемент <tbody id="book-list">, с заменой дочерних элементов.
То есть будут заменены все строки в теле таблицы, на отсортированные строки.


Теперь добавим стили, создадим директорию static и подключим её в файле настроек settings.py:
STATIC_URL = 'static/'
STATICFILES_DIRS = [BASE_DIR / 'static']
      
Затем создадим файл стилей static/base.css со следующим содержимым:
/* Задаёт отступ сверху и цвет страницы. */
body {
    padding-top: 50px;
    background-color: rgb(246, 246, 246);
}
/* Задаёт цвет заголовка таблицы. */
thead {
    background-color: rgb(240, 240, 240);
}
/* Задаёт цвет тела таблицы. */
tbody {
    background-color: rgb(252, 252, 252);
}
/* Задаёт размер шрифта таблицы. */
td {
    font-size: 14px;
}
/* Задаёт высоту строки таблицы. */
tr {
    line-height: 26px;
    min-height: 26px;
    height: 26px;
 }
/* Чтобы удалить ошибочное подчеркивание между символами сортировки. */
a {
    text-decoration: none;
}
/* Задаёт высоту текстовых полей формы редактирования книги. */
 .form-control-sm {
    line-height: 24px;
    min-height: 24px;
    height: 24px;
 }
/* Задаёт цвет шрифта для прочитанной книги. */
.grey-text {
    color: rgb(192, 192, 192);
}
/* Задаёт ширину кнопок Прочитана и Не прочитана. */
.status-button {
    width: 107px;
}
/* Задаёт ширину кнопок Изменить, Удалить, Сохранить и Отменить. */
.any-button {
    width: 80px;
}
/* Задаёт размер шрифта кнопок в таблице. */
.table-button {
    font-size: 13px;
}

Подключим файл стилей в шаблоне templates/base.html:
{% load static %}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{% block title %}Books{% endblock title %}</title>
    <link rel="stylesheet" href="{% static 'base.css' %}">
</head>

Добавим классы в шаблон templates/partial_book_detail.html:
<tr class="{% if book.read %}grey-text{% endif %}">
    <!-- Ячейка номера книги -->
Если книга прочитана, класс grey-text изменит цвет шрифта в строке на серый.

Добавим классы для кнопок:
                                <!-- Кнопка "Read/Unread" -->
                                <button class="disbtn table-button status-button"
...
                                <!-- Кнопка "Edit" -->
                                <button class="disbtn table-button any-button"
...
                                <!-- Кнопка "Delete" -->
                                <button class="disbtn table-button any-button"

Добавим классы для кнопок в шаблон templates/partial_book_update_form.html:
                    <tr class="{% if book.read %}grey-text{% endif %}">
...
                                <!-- Кнопка "Read/Unread" -->
                                <button class="table-button status-button" disabled>
...
                            <!-- Кнопка "Save" -->
                            <button type="submit"
                                    class="table-button any-button"
...
                            <!-- Кнопка "Cancel" -->
                            <button class="table-button any-button"

Добавим класс form-control-sm для текстовых полей, в файл  books/forms.py:
class BookEditForm(BookCreateForm):
    title  = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm"}))
    author = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm"}))
    price  = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm"}))





Добавление в проект Bootstrap 5
Подключим Bootstrap 5 и добавим его классы в шаблон templates/base.html:
{% load static %}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{% block title %}Books{% endblock title %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <link rel="stylesheet" href="{% static 'base.css' %}">
</head>
<body hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'>
<div class="container">
    <div class="row">
        <div class="col">
            <!-- Форма для добавления новой книги -->
            {% include "partial_create_book_form.html" %}

            <!-- Таблица книг -->
            <form class="form-inline">
                <table class="table table-bordered table-sm mt-5">
                    <thead>
                    <tr>
                        <!-- Заголовки столбцов таблицы -->
                        <!-- Заголовок номера книги -->
                        <th scope="col" style="width: 10%" class="text-center">
                            <small>
                                No.
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='id' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='id' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок названия книги -->
                        <th scope="col" style="width: 26%" class="text-center">
                            <small>
                                Title
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='title' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='title' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок автора книги -->
                        <th scope="col" style="width: 26%" class="text-center">
                            <small>
                                Author
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='author' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='author' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок цены книги -->
                        <th scope="col" style="width: 11%" class="text-center">
                            <small>
                                Price ($)
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='price' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='price' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок статуса книги -->
                        <th scope="col" style="width: 11%" class="text-center">
                            <small>
                                Status
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='read' direction='descend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇓
                                </a>
                                <a href=""
                                   hx-get="{% url 'book_list_sort' filter='read' direction='ascend' %}"
                                   hx-target="#book-list"
                                   hx-swap="innerHTML">
                                    ⇑
                                </a>
                            </small>
                        </th>
                        <!-- Заголовок кнопок действия -->
                        <th scope="col" style="width: 16%" class="text-center">
                            <small>
                                Actions
                            </small>
                        </th>

                    </tr>
                    </thead>
                    <!-- Список книг -->
                    <tbody id="book-list">
                    {% include "partial_book_list.html" %}
                    </tbody>

                </table>
            </form>
        </div>
    </div>
</div>
<script src="https://unpkg.com/htmx.org@1.9.4"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3"
        crossorigin="anonymous"></script>
<script>
    function cngElementsAtr(cls, atr, val) {
        var elems = document.getElementsByClassName(cls);
        for (var i = 0; i < elems.length; i++) {
            elems[i][atr] = val;
        }
    }
    document.body.addEventListener('htmx:afterRequest', (event) => {
        path_str = event.detail.pathInfo.requestPath;
        if (path_str.includes('create_book')) {
            cngElementsAtr('clrtxt', 'value', '');
        } else if (path_str.includes('update_book_details')) {
            if (event.detail.requestConfig.verb === 'get') {
                cngElementsAtr('disbtn', 'disabled', true);
            } else {
                cngElementsAtr('disbtn', 'disabled', false);
            }
        } else if (path_str.includes('book_detail')) {
            cngElementsAtr('disbtn', 'disabled', false);
        }
    });
</script>
</body>
</html>             
Добавим Bootstrap-классы в шаблон templates/partial_book_detail.html:
<tr class="{% if book.read %}grey-text{% endif %}">
    <!-- Ячейка номера книги -->
    <td class="align-middle text-center ps-2">
        {{ book.id }}
    </td>
    <!-- Ячейка названия книги -->
    <td class="align-middle ps-2">
        {{ book.title }}
    </td>
    <!-- Ячейка автора книги -->
    <td class="align-middle ps-2">
        {{ book.author }}
    </td>
    <!-- Ячейка цены книги -->
    <td class="align-middle text-center">
        {{ book.price }}
    </td>
    <!-- Ячейка состояния -->
    <td class="align-middle text-center">
    <!-- Кнопка "Read/Unread" -->
        <button class="disbtn table-button status-button btn btn-sm {% if book.read %}btn-secondary{% else %}btn-primary{% endif %}"
                hx-patch="{% url 'update_book_status' book.id %}"
                hx-target="closest tr"
                hx-swap="outerHTML">
            {% if book.read %}Read{% else %}Unread{% endif %}
        </button>
    </td>
    <!--  Ячейка кнопок действия -->
    <td class="align-middle text-center">
        <!-- Кнопка "Edit" -->
        <button class="disbtn table-button any-button btn btn-primary btn-sm me-2"
                hx-get="{% url 'update_book_details' book.id %}"
                hx-target="closest tr"
                hx-swap="outerHTML">
            Edit
        </button>
        <!-- Кнопка "Delete" -->
        <button class="disbtn table-button any-button btn btn-danger btn-sm"
                hx-delete="{% url 'delete_book' book.id %}"
                hx-target="closest tr"
                hx-swap="outerHTML"
                hx-confirm="Are you sure you wish to delete this book?">
            Delete
        </button>
    </td>
</tr>
Добавим Bootstrap-классы в шаблон templates/partial_book_update_form.html:
<tr class="{% if book.read %}grey-text{% endif %}">
    <!-- Ячейка номера книги -->
    <td class="align-middle text-center ps-2">
        {{ book.id }}
    </td>
    <!-- Ячейка названия книги -->
    <td class="align-middle ps-2">
        {{ form.title }}
    </td>
    <!-- Ячейка автора книги -->
    <td class="align-middle ps-2">
        {{ form.author }}
    </td>
    <!-- Ячейка цены книги -->
    <td class="align-middle text-center">
        {{ form.price }}
    </td>

    <!-- Ячейка состояния -->
    <td class="align-middle text-center">
        <!-- Кнопка "Read/Unread" -->
        <button class="disbtn table-button status-button btn btn-sm {% if book.read %}btn-secondary{% else %}btn-primary{% endif %}" disabled>
            {% if book.read %}Read{% else %}Unread{% endif %}
        </button>
    </td>
    <!--  Ячейка кнопок действия -->
    <td class="align-middle text-center">
        <!-- Кнопка "Save" -->
        <button type="submit"
                class="table-button any-button btn btn-success btn-sm me-2"
                hx-post="{% url 'update_book_details' book.id %}"
                hx-target="closest tr"
                hx-swap="outerHTML"
                hx-include="closest tr">
            Save
        </button>
        <!-- Кнопка "Cancel" -->
        <button class="table-button any-button btn btn-warning btn-sm"
                hx-get="{% url 'book_detail' book.id %}"
                hx-target="closest tr"
                hx-swap="outerHTML">
            Cancel
        </button>
    </td>
</tr>
Добавим Bootstrap-классы в шаблон templates/partial_create_book_form.html:
<form class="form-inline">
    <div class="row">
        <div class="col">
            {{ form.title }}
        </div>

        <div class="col">
            {{ form.author }}
        </div>
        <div class="col">
            {{ form.price }}
        </div>
        <div class="col">
            <!-- Кнопка "Add book" -->
            <button type="submit"
                    class="disbtn btn btn-primary"
                    hx-post="{% url 'create_book' %}"
                    hx-target="#book-list"
                    hx-swap="beforeend">
                Add book
            </button>
        </div>
    </div>
</form>
Добавим Bootstrap-класс form-control в файл books/forms.py:
class BookEditForm(BookCreateForm):
    title  = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm form-control"}))
    author = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm form-control"}))
    price  = CharField(required=False, widget=TextInput(attrs={"class":"form-control-sm form-control"}))



Затем заменим символы стрелок сортировки на иконки из библиотеки Bootstrap Icons.
Подключим их в заголовке шаблона templates/base.html:
<head>
    <meta charset="utf-8">
    <title>{% block title %}Books{% endblock title %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{% static 'base.css' %}">
</head>
Затем в этом же шаблоне заменим символы стрелок:
Символ ⇓ заменим на тег <i class="table-icon bi bi-arrow-down-square ms-1"></i>.
А символ ⇑ заменим на тег <i class="table-icon bi bi-arrow-up-square"></i>


И завершающий штрих, сделаем так, что-бы нажатая кнопка сортировки становилась неактивной.
Добавим новый класс disabled-button, для неактивных кнопок сортировки, в файл static/base.css:
/* Отключает кнопки сортировки. */
.disabled-button {
      opacity: 0.5;
      pointer-events: none;
 }
Добавим новые классы *-ascend и *-descend для кнопок сортировки в файл templates/base.html.
И туда-же добавим класс disabled-button для кнопки сортировки по-возрастанию номера книги.
По-умолчанию эта кнопка будет заблокирована - так-как список книг изначально выводится именно так.
                            <!-- Заголовок номера книги -->
                            <th scope="col" style="width: 10%" class="text-center">
                                <small>
                                    No.
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='id' direction='descend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-down-square ms-1 id-descend"></i>
                                    </a>
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='id' direction='ascend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-up-square id-ascend disabled-button"></i>
                                    </a>
                                </small>
                            </th>
                            <!-- Заголовок названия книги -->
                            <th scope="col" style="width: 26%" class="text-center">
                                <small>
                                    Title
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='title' direction='descend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-down-square ms-1 title-descend"></i>
                                    </a>
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='title' direction='ascend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-up-square title-ascend"></i>
                                    </a>
                                </small>
                            </th>
                            <!-- Заголовок автора книги -->
                            <th scope="col" style="width: 26%" class="text-center">
                                <small>
                                    Author
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='author' direction='descend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-down-square ms-1 author-descend"></i>
                                    </a>
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='author' direction='ascend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-up-square author-ascend"></i>
                                    </a>
                                </small>
                            </th>
                            <!-- Заголовок цены книги -->
                            <th scope="col" style="width: 11%" class="text-center">
                                <small>
                                    Price ($)
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='price' direction='descend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-down-square ms-1 price-descend"></i>
                                    </a>
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='price' direction='ascend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-up-square price-ascend"></i>
                                    </a>
                                </small>
                            </th>
                            <!-- Заголовок статуса книги -->
                            <th scope="col" style="width: 11%" class="text-center">
                                <small>
                                    Status
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='read' direction='descend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-down-square ms-1 read-descend"></i>
                                    </a>
                                    <a href=""
                                       hx-get="{% url 'book_list_sort' filter='read' direction='ascend' %}"
                                       hx-target="#book-list"
                                       hx-swap="innerHTML" >
                                        <i class="table-icon bi bi-arrow-up-square read-ascend"></i>
                                    </a>
                                </small>
                            </th>
Там же доработаем код для блокировки-разблокировки кнопок сортировки:
    <script>
        function cngElementsAtr(cls, atr, val){
            var elems = document.getElementsByClassName(cls);
            for(var i = 0; i < elems.length; i++) {
                elems[i][atr] = val;
            }
        }
        document.body.addEventListener('htmx:afterRequest', (event) => {
            path_str = event.detail.pathInfo.requestPath;
            if(path_str.includes('create_book')){
                cngElementsAtr('clrtxt', 'value', '');
            }else if(path_str.includes('update_book_details')){
                if(event.detail.requestConfig.verb === 'get'){
                    cngElementsAtr('disbtn', 'disabled', true);
                }else{
                    cngElementsAtr('disbtn', 'disabled', false);
                }
            }else if(path_str.includes('book_detail')){
                cngElementsAtr('disbtn', 'disabled', false);
            }else if(path_str.includes('book_list_sort')){
                path_arr = path_str.split('/');
                path_arr.pop()
                curr_class = path_arr.pop()
                curr_class = path_arr.pop() + '-' + curr_class
                document.getElementsByClassName('disabled-button')[0].classList.remove('disabled-button');
                document.getElementsByClassName(curr_class)[0].classList.add('disabled-button');
            }
        });
    </script>

AJAX: Asynchronous JavaScript And XML
AJAX — не технология, а концепция использования существующих технологий для асинхронного взаимодействия клиента и сервера.
Этапы запроса:
Инициализация - создание XHR/fetch

Открытие соединения - xhr.open()

Отправка заголовков - автоматически или через setRequestHeader()

Отправка тела - xhr.send() или body в fetch

Получение ответа - обработка через event handlers


Интернационализация и локализация в Django
Команды управления интернационализацией
Django содержит следующие команды, служащие для управления переводами:
makemessages: пробегает по дереву исходного кода, чтобы отыскать все строковые литералы, помеченные для перевода, и создает или обновляет файлы сообщений .po в каталоге locale. По каждому языку создается один файл .po;
compilemessages: компилирует существующие файлы сообщений .po в файлы .mo, которые используются для извлечения переводов.
 
Установка инструментария gettext
Для того чтобы иметь возможность создавать, обновлять и компилировать файлы сообщений, понадобится инструментарий gettext.
Большинство дистрибутивов Linux уже содержат инструментарий gettext.
Если же вы используете macOS, то самый простой способ его установить – применить утилиту Homebrew (расположенную по адресу https://brew.sh/) следующей ниже командой:
brew install gettext
Кроме того, возможно, понадобится связать его принудительно с помощью такой команды:
brew link --force gettext
Если вы используете Windows, то следуйте инструкциям по адресу https://docs.djangoproject.com/en/5.0/topics/i18n/translation/#gettext-on-windows.
Предкомпилированный бинарный установщик инструментария gettext для Windows можно скачать со страницы https://mlocati.github.io/articles/gettext-iconv-windows.html.


Как добавлять переводы в проект Django
Давайте посмотрим на процесс интернационализации проекта. Он состоит из следующих действий:
1. Отметить подлежащие переводу строковые литералы в своем коде Python и шаблонах;
2. Выполнить команду makemessages, чтобы создать или обновить файлы сообщений, включающие все переводные строковые литералы из исходного кода;
3. Перевести содержащиеся в файлах сообщений строковые литералы и скомпилировать их с помощью команды управления compilemessages.

Как Django определяет текущий язык
Django поставляется с компонентом фреймворка промежуточных программных компонентов, который определяет текущий язык на основе данных запроса.
Это класс LocaleMiddleware, который находится в django.middleware.locale.LocaleMiddleware и выполняет следующую работу:
1. Если используется i18n_patterns, то есть применяются переведенные шаблоны URL-адресов, то в запрошенном URL-адресе отыскивается префикс языка, чтобы определить текущий язык.
2. Если языковой префикс не найден, то в сеансе текущего пользователя отыскивается существующий языковой сеансовый ключ, LANGUAGE_SESSION_KEY.
3. Если язык в сеансе не задан, то отыскивается существующий cookie-файл с текущим языком. Конкретно-прикладное имя этого cookie-файла можно указать в настроечном параметре LANGUAGE_COOKIE_NAME.
По умолчанию cookie-файл имеет имя django_language.
4. Если cookie-файл не найден, то отыскивается HTTP-заголовок Accept-Language запроса.
5. Если в заголовке Accept-Language язык не указан, то Django использует язык, указанный в настроечном параметре LANGUAGE_CODE.
По умолчанию Django будет использовать язык, указанный в настроечном параметре LANGUAGE_CODE, при условии что не используется промежуточный компонент LocaleMiddleware.
Описанный здесь процесс применим только при использовании этого компонента фреймворка промежуточных программных компонентов.


Перевод исходного кода Python
Для того чтобы перевести строковые литералы в исходном коде Python, можно пометить строковые литералы для перевода с помощью включенной в django.utils.translation функции gettext(). Эта функция переводит сообщение и возвращает строковый литерал.
По традиции указанная функция импортируется как более короткий псевдоним с именем _ (символ подчеркивания).
Вся документация о переводах находится на странице https://docs.djangoproject.com/en/5.0/topics/i18n/translation/.

Стандартные переводы
Следующий ниже исходный код показывает, как помечать строковый литерал для перевода:
from django.utils.translation import gettext as _
output = _('Text to be translated.')
           
Ленивые переводы
Django содержит ленивые версии всех своих переводных функций, которые имеют суффикс _lazy(). При использовании ленивых функций строковые литералы переводятся при доступе к значению, а не при вызове функции (поэтому они переводятся лениво).
Функции ленивого перевода пригодятся, когда помеченные для перевода строковые литералы будут находиться в путях, которые задействуются при загрузке модулей.

Переводы с переменными
Помеченные для перевода строковые литералы могут содержать местозаполнители, чтобы вставлять в переводы переменные. Следующий ниже исходный код является примером строкового литерала для перевода с местозаполнителем:
from django.utils.translation import gettext as _
month = _('April')
day = '14'
output = _('Today is %(month)s %(day)s') % {'month': month, 'day': day}
Используя местозаполнители, можно переупорядочивать текстовые переменные.
Например, английский перевод приведенного выше примера будет Today is April 14, а русский – Сегодня 14 апреля.
Если в переводном строковом литерале есть более одного параметра, то следует всегда придерживаться строковой интерполяции вместо позиционной. Благодаря этому можно переупорядочивать текст с местозаполнителями.

Формы множественного числа в переводах
Для форм множественного числа можно использовать функции ngettext() и ngettext_lazy().
Эти функции переводят формы единственного и множественного числа в зависимости от аргумента, указывающего число объектов.
В следующем ниже примере показано, как их использовать:
output = ngettext('there is %(count)d product', 'there are %(count)d products', count) % {'count': count}
Теперь, когда вы знаете основы перевода строковых литералов в своем исходном коде Python, самое время применить переводы к проекту

Перевод собственного исходного кода

Отредактируйте файл settings.py проекта, импортировав функцию gettext_lazy() и изменив настроечный параметр LANGUAGES, как показано ниже, чтобы переводить названия языков:

from django.utils.translation import gettext_lazy as _
# ...

LANGUAGES = [
    ('en', _('English')),
    ('ru', _('Russian')),
]

                  

Здесь вместо функции gettext() используется функция gettext_lazy(), чтобы избежать циклического импорта, тем самым переводя названия языков при доступе к ним.
Откройте оболочку и выполните следующую команду из каталога проекта:
django-admin makemessages --all --ignore venv
Взгляните на каталог locale\. Вы должны увидеть файловую структуру, подобную следующей ниже:
Для каждого языка создан файл сообщений .po.
С помощью текстового редактора откройте ru\LC_MESSAGES\django.po. В конце файла вы увидите следующее:
#: django_htmx/settings.py:108
msgid "English"
msgstr ""
#: django_htmx/settings.py:109
msgid "Russian"
msgstr ""
Каждому переводному строковому литералу предшествует комментарий, показывающий детальную информацию о файле и строковый литерал, в котором он был найден. Каждый перевод включает два строковых литерала:
msgid: переводной строковый литерал в том виде, в каком он представлен в исходном коде;
msgstr: языковой перевод, который по умолчанию пуст. Здесь нужно ввести фактический перевод данного строкового литерала.
Заполните переводы msgstr данного строкового литерала msgid, как показано ниже:
#: django_htmx/settings.py:108
msgid "English"
msgstr "Английский"
#: django_htmx/settings.py:109
msgid "Russian"
msgstr "Русский"
Сохраните видоизмененный файл сообщения, откройте оболочку и выполните такую команду:
django-admin compilemessages --ignore venv
Если все пройдет хорошо, то вы должны увидеть результат, подобный следующему ниже:
Указанный результат показывает информацию о скомпилированных файлах сообщений.
Ещё раз взгляните на каталог locale\, вы увидите показанные далее файлы:
Как видите, для каждого языка был скомпилирован файл сообщений .mo.


Вы перевели названия языков. Теперь давайте переведем имена полей модели, которые отображаются на сайте.
Отредактируйте файл models.py приложения books, добавив помеченные для перевода имена в поля модели Book, как показано ниже:
from django.db import models
from django.utils.translation import gettext_lazy as _
class Book(models.Model):
    title = models.CharField(verbose_name=_('Title'), max_length=200)
    author = models.CharField(verbose_name=_('Author'), max_length=200)
    price = models.PositiveIntegerField(verbose_name=_('Price'), default=0)
    read = models.BooleanField(verbose_name=_('Read'), default=False)
    def __str__(self):
        return self.title
Вы добавили имена для полей, которые отображаются, когда пользователь добавляет новую книгу. Это поля title, author, price и read.
Внутри каталога приложения books создайте следующую ниже каталожную структуру:
При создании каталога locale переводные строковые литералы этого приложения будут храниться в файле сообщений в этом каталоге, а не в главном файле сообщений. Благодаря этому можно генерировать отдельные файлы перевода по каждому приложению.
Откройте оболочку из каталога проекта и выполните следующую ниже команду:
django-admin makemessages --all --ignore venv
Вы должны увидеть такой результат:
С помощью текстового редактора откройте файл books\locale\ru\LC_MESSAGES\django.po приложения books.
Вы увидите переводные строковые литералы из модели Book.
Заполните следующие ниже переводы msgstr для строковых литералов msgid:
#: books/models.py:6
msgid "Title"
msgstr "Название"
#: books/models.py:7
msgid "Author"
msgstr "Автор"
#: books/models.py:8
msgid "Price"
msgstr "Цена"
#: books/models.py:9
msgid "Read"
msgstr "Прочитано"
Закончив добавлять переводы, сохраните файл.
Внимание: после любых изменений файлов переводов необходимо выполнять их компиляцию с помощью команды:
django-admin compilemessages --ignore venv
Помимо текстового редактора, для редактирования переводов еще можно использовать Poedit.
Poedit – это программный продукт, служащий для редактирования переводов, в котором используется инструментарий gettext. Он доступен для Linux, Windows и macOS.
Программу Poedit можно скачать со страницы с https://poedit.net/.


Перевод шаблонов
Django предлагает теги {% trans %} и {% blocktrans %} для перевода строковых литералов в шаблонах. Для того чтобы использовать шаблонные теги перевода, необходимо в верхнюю часть шаблона добавить тег {% load i18n %}, который будет их загружать.
Шаблонный тег {% trans %}
Шаблонный тег {% trans %} позволяет помечать строковый литерал для перевода. На внутреннем уровне Django выполняет функцию gettext() с заданным текстом в качестве параметра.
Вот как строковый литерал помечается в шаблоне:
{% trans "Text to be translated" %}
Притом можно использовать ключевое слово as, чтобы сохранять переведенный контент в переменной, которую можно использовать в своем шаблоне.
В следующем ниже примере переведенный текст сохраняется в переменной с именем greeting:
{% trans "Hello!" as greeting %}
<h1>{{ greeting }}</h1>
Тег {% trans %} удобен для простых переводных строковых литералов, но он не способен обрабатывать переводной контент, содержащий переменные.
Шаблонный тег {% blocktrans %}
Шаблонный тег {% blocktrans %} позволяет помечать контент, содержащий строковые литералы и переменные, используя местозаполнители.
В следующем ниже примере показано, как использовать тег {% blocktrans %}, содержащий переменную name в контенте для перевода:
{% blocktrans %}Hello {{ name }}!{% endblocktrans %}
Притом можно использовать ключевое слово with, чтобы вставлять шаблонные выражения, такие как доступ к объектным атрибутам или применение шаблонных фильтров к переменным. Для них всегда следует использовать местозаполнители.
Вместе с тем ни к выражениям, ни к объектным атрибутам внутри блока blocktrans обратиться невозможно.
В следующем ниже примере показано, как использовать with для вставки объектного атрибута, к которому был применен фильтр capfirst:
{% blocktrans with name=user.name|capfirst %}
    Hello {{ name }}!
{% endblocktrans %}